<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>JS101</title>
    <link href="http://101.js.org/feed.xml" rel="self" />
    <link href="http://101.js.org/" />
    <id>http://101.js.org/feed.xml</id>
    <entry>
        <title type="html"><![CDATA[闭包]]></title>
        <link href="http://101.js.org/javascript-101/closures.html"/>
        <published>2015-04-21T00:00:00.000Z</published>
        <updated>2015-04-21T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/closures.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>闭包是作用域概念的扩展。通过闭包，函数可以访问存在函数被创建的作用域中的变量。如果这显得令人困惑，别担心：闭包一般最适合通过例子来理解。</p>
<p>如同<a href="scope.html">作用域</a>部分所示，函数可以访问变化的变量值。定义在循环中的函数也存在同样的行为 － 即使在函数定义之后，它依然能观察到变量的值发生了改变，导致每一个函数都引用了保存在变量中的最后值。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Each function executed within the loop will reference</span>
<span class="comment">// the last value stored in i (5).</span>
<span class="comment">// This won't behave as we want it to - every 100 milliseconds, 5 will alert</span>
<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) {
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert( i );
    }, i * <span class="number">100</span> );
}</code></pre></div><p>闭包可以用来防止这种情况，通过给每一次迭代创建一个独特的作用域 － 在其作用域内保存变量的每一个独特值。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Using a closure to create a new private scope</span>
<span class="comment">// fix: “close” the value of i inside createFunction, so it won't change</span>
<span class="keyword">var</span> createFunction = <span class="function"><span class="keyword">function</span><span class="params">( i )</span> {</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert( i );
    };
};

<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) {
    setTimeout( createFunction( i ), i * <span class="number">100</span> );
}</code></pre></div><p>闭包也可以用来解决 <code>this</code> 关键字的问题，它是每个作用域的唯一值：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Using a closure to access inner and outer object instances simultaneously.</span>
<span class="keyword">var</span> outerObj = {
    myName: <span class="string">"outer"</span>,
    outerFunction: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

        <span class="comment">// Provide a reference to outerObj through innerFunction's closure</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">var</span> innerObj = {
            myName: <span class="string">"inner"</span>,
            innerFunction: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                console.log( self.myName, <span class="keyword">this</span>.myName ); <span class="comment">// "outer inner"</span>
            }
        };

        innerObj.innerFunction();

        console.log( <span class="keyword">this</span>.myName ); <span class="comment">// "outer"</span>
    }
};

outerObj.outerFunction();</code></pre></div><h2 id="function-bind">Function.bind</h2><p>当处理回调函数时，闭包也是特别有用的。但是，通常更好的做法是使用 <code>Function.bind</code>，它可以避免任何作用域遍历相关的过度开销。</p>
<p><code>Function.bind</code> 被用来创建一个新函数。当新函数被调用时，函数会在 <code>.bind()</code> 方法中提供的 <code>this</code> 上下文中执行，并使用一系列 <code>.bind()</code> 方法中提供的参数与函数调用时提供的任何参数。</p>
<p>由于 <code>.bind()</code> 是在 ECMAScript 5 中添加的，它可能不会得到所有浏览器的支持，当决定是否使用它时，这是值得注意的一点。不过，我们可以使用 MDN 提供的<a href="https://developer.mozilla.org/zh-CN/JavaScript/Reference/Global_Objects/Function/bind">兼容代码</a>来使 <code>.bind()</code> 正常工作。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Shim from MDN</span>
<span class="keyword">if</span> (!Function.prototype.bind) {

    Function.prototype.bind = <span class="function"><span class="keyword">function</span><span class="params">( oThis )</span> {</span>

        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) {
            <span class="comment">// closest thing possible to the ECMAScript 5 internal</span>
            <span class="comment">// IsCallable function</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> TypeError( <span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span> );
        }

        <span class="keyword">var</span> fSlice = Array.prototype.slice,
            aArgs = fSlice.call( arguments, <span class="number">1</span> ),
            fToBind = <span class="keyword">this</span>,
            fNOP = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>},
            fBound = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">return</span> fToBind.apply( <span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP
                    ? <span class="keyword">this</span>
                    : oThis || window,
                    aArgs.concat( fSlice.call( arguments ) ) );
            };

        fNOP.prototype = <span class="keyword">this</span>.prototype;

        fBound.prototype = <span class="keyword">new</span> fNOP();

        <span class="keyword">return</span> fBound;
    };
}</code></pre></div><p><code>.bind()</code> 最简单的用途之一是创建一个使用特定 <code>this</code> 值的函数，而无关该函数是如何调用的。一个开发者常常出现的错误是试图从对象中提取一个方法，在随后调用该方法时期望使用原始对象作为 <code>this</code> 值。这时可以通过创建一个函数绑定原始对象来解决类似问题，如下所示：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Let's manipulate "this" with a basic example.</span>
<span class="keyword">var</span> user = <span class="string">"johnsmith"</span>;
<span class="keyword">var</span> module = {
    getUser: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.user;
    },
    user: <span class="string">"janedoe"</span>
};

<span class="comment">// module.getUser() is called where "module" is "this"</span>
<span class="comment">// and "module.user" is returned.</span>

<span class="comment">// janedoe</span>
module.getUser();

<span class="comment">// let's now store a reference in the global version of "this"</span>
<span class="keyword">var</span> getUser = module.getUser;

<span class="comment">// getUser() called, "this" is global, "user" is returned</span>

<span class="comment">// johnsmith</span>
getUser();

<span class="comment">// store a ref with "module" bound as "this"</span>
<span class="keyword">var</span> boundGetUser = getUser.bind( module );

<span class="comment">// boundGetUser() called, "module" is "this" again, "module.user" returned.</span>

<span class="comment">// janedoe</span>
boundGetUser();</code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[作用域]]></title>
        <link href="http://101.js.org/javascript-101/scope.html"/>
        <published>2015-04-19T00:00:00.000Z</published>
        <updated>2015-04-19T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/scope.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>作用域通常是指在指定的时间内，变量存在于一段代码中。缺乏对作用域的理解可能会导致令人沮丧的调试体验。作用域的概念是关于我们的代码中可以访问到哪些确定的函数或变量，代码的上下文和执行环境。</p>
<p>在 JavaScript 中，有两种类型的作用域：全局和局部作用域。</p>
<h2 id="全局作用域">全局作用域</h2><p>第一种作用域是<strong>全局作用域</strong>。它很容易定义。如果一个变量或函数是<em>全局的</em>，那么在程序中的任何地方都可以访问到它们。在浏览器中，全局作用域是 <code>window</code> 对象。如果在函数外面声明一个变量，那么这个变量就存在全局对象中。例如：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> x = <span class="number">9</span>;</code></pre></div><p>一旦该变量被定义，则可以被引用为 <code>window.x</code>，因为它存在于全局对象中，我们可以简单的引用它为 <code>x</code>。</p>
<h2 id="局部作用域">局部作用域</h2><p>JavaScript 也可以在每个函数体中创建<strong>局部作用域</strong>。例如：</p>
<div class="highlight"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> x = <span class="number">5</span>;
}

myFunc();

console.log( x ); <span class="comment">// ReferenceError: x is not defined</span></code></pre></div><p>由于 <code>x</code> 是在 <code>myFunc()</code> 中初始化，所以它只能在 <code>myFunc()</code> 中被访问，如果我们试图在 <code>myFunc()</code> 外面访问 <code>x</code>，则会得到一个引用错误。</p>
<h2 id="注意">注意</h2><p>如果你忘记使用 <code>var</code> 关键字声明变量，那么这个变量会自动变成全局变量。所以这段代码可以运行：</p>
<div class="highlight"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span><span class="params">()</span> {</span>
    x = <span class="number">5</span>;
}

myFunc();

console.log( x ); <span class="comment">// 5</span></code></pre></div><p>这是一个坏主意。全局变量的值可以被程序的任何部分或者其他脚本更改。这是不期望发生的，因为它会导致无法预料的副作用。</p>
<p>立即调用表达式（IIFE）提供了一个避免全局变量的方式。你会看到许多如 jQuery 的 JavaScript 库经常使用这种方式：</p>
<div class="highlight"><pre><code class="javascript">(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> jQuery = { <span class="comment">/* All my methods go here. */</span> };
    window.jQuery = jQuery;
})();</code></pre></div><p>将一切包含在一个函数中并立即调用这个函数，这意味着函数中的所有变量都被绑定在<em>局部作用域</em>中。在函数结尾部分，你可以通过将 <code>jQuery</code> 对象绑定在全局对象 <code>window</code> 上，将一些方法和属性公开出来。了解更多关于立即调用函数表达式，请查看 Ben Alman 的文章 <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression</a>。</p>
<p>因为局部作用域通过函数而工作，任何在另一个函数中定义的函数都可以访问外部函数里的变量：</p>
<div class="highlight"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> x = <span class="number">5</span>;

    <span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">()</span> {</span>
        console.log( x );
    }

    inner(); <span class="comment">// 5</span>
}</code></pre></div><p>但是 <code>.outer()</code> 函数不能访问 <code>.inner()</code> 函数中定义的任何变量。</p>
<div class="highlight"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> x = <span class="number">5</span>;

    <span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">()</span> {</span>
        console.log( x );
        <span class="keyword">var</span> y = <span class="number">10</span>;
    }

    inner(); <span class="comment">// 5</span>

    console.log( y ); <span class="comment">// ReferenceError: y is not defined</span>
}</code></pre></div><p>另外，在一个函数中没有使用 <code>var</code> 关键字定义的变量不是这个函数的局部变量 － JavaScript 会向上遍历作用域链（最后会到 <code>window</code> 对象）寻找之前定义的这个变量。如果这个变量没有定义，则会在全局中定义该变量，这样会导致意外的结果。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Functions have access to variables defined in the same scope.</span>

<span class="keyword">var</span> foo = <span class="string">"hello"</span>;

<span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log( foo );
};

sayHello(); <span class="comment">// "hello"</span>

console.log( foo ); <span class="comment">// "hello"</span></code></pre></div><p>相同名称的变量可以在不同作用域中保存不同的值：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> foo = <span class="string">"world"</span>;

<span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> foo = <span class="string">"hello"</span>;
    console.log( foo );
};

sayHello(); <span class="comment">// "hello"</span>

console.log( foo ); <span class="comment">// "world"</span></code></pre></div><p>当在一个函数中引用一个外部作用域定义的变量，函数可以访问在该函数定义之后发生改变的变量值。</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> foo = <span class="string">"hello"</span>;
    <span class="keyword">var</span> myFn = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log( foo );
    };
    foo = <span class="string">"world"</span>;
    <span class="keyword">return</span> myFn;
};

<span class="keyword">var</span> f = myFunction();

f(); <span class="comment">// "world"</span></code></pre></div><p>这是一个更复杂的作用域例子：</p>
<div class="highlight"><pre><code class="javascript">(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

    <span class="keyword">var</span> baz = <span class="number">1</span>;

    <span class="keyword">var</span> bim = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log( baz );
    };

    bar = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log( baz );
    };

})();</code></pre></div><p>在这个实例中，运行：</p>
<div class="highlight"><pre><code class="javascript">console.log( baz ); <span class="comment">// baz is not defined outside of the function</span></code></pre></div><p>将会得到一个 <code>ReferenceError</code>。<code>baz</code> 仅仅是在函数中定义，并且没有暴露在全局作用域中。</p>
<div class="highlight"><pre><code class="javascript">bar(); <span class="comment">//  1</span></code></pre></div><p><code>.bar()</code> 是在匿名函数中定义的， 但是它没有使用 <code>var</code> 关键字定义，这意味着它没有绑定到局部作用域，而是在全局作用域创建。另外，它可以访问 <code>baz</code>
变量，因为 <code>.bar()</code> 是在与 <code>baz</code> 相同的作用域定义的，所以它可以访问变量 <code>baz</code>，即使函数外部的其他代码不可以。</p>
<div class="highlight"><pre><code class="javascript">bim(); <span class="comment">// ReferenceError: bim is not defined</span></code></pre></div><p><code>.bim()</code> 只在函数中定义的，所以它作为局部变量而不存在于全局对象中。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[函数]]></title>
        <link href="http://101.js.org/javascript-101/functions.html"/>
        <published>2015-04-09T00:00:00.000Z</published>
        <updated>2015-04-09T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/functions.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>函数包含需要反复执行的代码块。函数可以取零个或多个参数，并且可以可选的返回一个值。</p>
<p>函数可以通过各种方式创建，其中两个方式如下：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Function declaration.</span>

<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> {</span>
    <span class="comment">// Do something.</span>
}</code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// Function expression.</span>

<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="comment">// Do something.</span>
};</code></pre></div><h2 id="使用函数">使用函数</h2><div class="highlight"><pre><code class="javascript"><span class="comment">// A simple function.</span>

<span class="keyword">var</span> greet = <span class="function"><span class="keyword">function</span><span class="params">( person, greeting )</span> {</span>
    <span class="keyword">var</span> text = greeting + <span class="string">", "</span> + person;
    console.log( text );
};

greet( <span class="string">"Rebecca"</span>, <span class="string">"Hello"</span> ); <span class="comment">// "Hello, Rebecca"</span></code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// A function that returns a value.</span>

<span class="keyword">var</span> greet = <span class="function"><span class="keyword">function</span><span class="params">( person, greeting )</span> {</span>
    <span class="keyword">var</span> text = greeting + <span class="string">", "</span> + person;
    <span class="keyword">return</span> text;
};

console.log( greet( <span class="string">"Rebecca"</span>, <span class="string">"Hello"</span> ) ); <span class="comment">// "Hello, Rebecca"</span></code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// A function that returns another function.</span>

<span class="keyword">var</span> greet = <span class="function"><span class="keyword">function</span><span class="params">( person, greeting )</span> {</span>
    <span class="keyword">var</span> text = greeting + <span class="string">", "</span> + person;
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log( text );
    };
};

<span class="keyword">var</span> greeting = greet( <span class="string">"Rebecca"</span>, <span class="string">"Hello"</span> );

greeting(); <span class="comment">// "Hello, Rebecca"</span></code></pre></div><h2 id="立即调用函数表达式（iife）">立即调用函数表达式（IIFE）</h2><p>在 JavaScript 中一个常见的模式是立即调用函数表达式。这种模式创建一个函数表达式然后立即执行。IIFE 在要避免污染全局命名空间的情况下非常有用 － 函数内声明的变量，在外部是不可见的。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// An immediately-invoked function expression.</span>

(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> foo = <span class="string">"Hello world"</span>;
})();

console.log( foo ); <span class="comment">// undefined!</span></code></pre></div><h2 id="作为参数的函数">作为参数的函数</h2><p>在 JavaScript 中，函数是“一等公民” － 它们可以被赋给变量或者作为参数传递给另一个函数。传递函数作为参数是 jQuery 中的惯用法。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Passing an anonymous function as an argument.</span>

<span class="keyword">var</span> myFn = <span class="function"><span class="keyword">function</span><span class="params">( fn )</span> {</span>
    <span class="keyword">var</span> result = fn();
    console.log( result );
};

<span class="comment">// Logs "hello world"</span>
myFn( <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="string">"hello world"</span>;
});</code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// Passing a named function as an argument</span>

<span class="keyword">var</span> myFn = <span class="function"><span class="keyword">function</span><span class="params">( fn )</span> {</span>
    <span class="keyword">var</span> result = fn();
    console.log( result );
};

<span class="keyword">var</span> myOtherFn = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="string">"hello world"</span>;
};

myFn( myOtherFn ); <span class="comment">// "hello world"</span></code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[对象]]></title>
        <link href="http://101.js.org/javascript-101/objects.html"/>
        <published>2015-04-08T00:00:00.000Z</published>
        <updated>2015-04-08T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/objects.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>对象包含一个或更多键值对。键的部分可以是任何字符串。值的部分可以是任何类型的值：数字、字符串、数组、函数，甚至是另一个对象。当这些值中的一个是函数，它被称为对象的方法。否则，它们被称为属性。</p>
<p>事实上，JavaScript 中的所有东西几乎都是对象 － 数组，函数，数字，甚至字符串 － 它们都有属性和方法。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Creating an object literal.</span>

<span class="keyword">var</span> myObject = {
    sayHello: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log( <span class="string">"hello"</span> );
    },
    myName: <span class="string">"Rebecca"</span>
};

myObject.sayHello(); <span class="comment">// "hello"</span>

console.log( myObject.myName ); <span class="comment">// "Rebecca"</span></code></pre></div><p>创建对象字面量时，注意每一个键值对的键部分可以是任何有效的 JavaScript 标识符、字符串（被引号包含）或者数字：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> myObject = {
    validIdentifier: <span class="number">123</span>,
    <span class="string">"some string"</span>: <span class="number">456</span>,
    <span class="number">99999</span>: <span class="number">789</span>
};</code></pre></div><h2 id="遍历对象的可枚举属性：">遍历对象的可枚举属性：</h2><div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> myObject = {
    validIdentifier: <span class="number">123</span>,
    <span class="string">"some string"</span>: <span class="number">456</span>,
    <span class="number">99999</span>: <span class="number">789</span>
};

<span class="keyword">for</span> ( <span class="keyword">var</span> prop <span class="keyword">in</span> myObject ) {
    <span class="comment">// Determine if the property is on the object itself.</span>
    <span class="comment">// (not on the prototype)</span>
    <span class="keyword">if</span> ( myObject.hasOwnProperty( prop ) ) {
        console.log( <span class="string">"Property : "</span> + prop + <span class="string">" ; value : "</span> + myObject[ prop ] );
    }
}

<span class="comment">// Would log the following:</span>
<span class="comment">// Please note that the order is not guaranteed and may differ.</span>

<span class="comment">// Property : 99999 ; value : 789</span>
<span class="comment">// Property : validIdentifier ; value : 123</span>
<span class="comment">// Property : some string ; value : 456</span></code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[数组]]></title>
        <link href="http://101.js.org/javascript-101/arrays.html"/>
        <published>2015-03-28T00:00:00.000Z</published>
        <updated>2015-03-28T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/arrays.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>数组是从零索引，值的有序列表。数组是一个简便的方式来存储一组相同类型的有关项（例如字符串），但实际上，一个数组可以包含多个类型的项，甚至是其他数组。</p>
<p>创建一个数组，可以使用数组构造函数或者字面量声明式，在声明后，可以赋给变量一系列的值。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// A simple array with constructor.</span>
<span class="keyword">var</span> myArray1 = <span class="keyword">new</span> Array( <span class="string">"hello"</span>, <span class="string">"world"</span> );

<span class="comment">// Literal declaration, the preferred way.</span>
<span class="keyword">var</span> myArray2 = [ <span class="string">"hello"</span>, <span class="string">"world"</span> ];</code></pre></div><p>字面量声明式通常是更好的选择。查看<a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Array_and_Object_literals">谷歌编码指南</a>可获得更多信息。</p>
<p>如果值是未知的，也可以创建一个空的数组，然后通过数组方法或者访问索引来添加元素：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Creating empty arrays and adding values</span>

<span class="keyword">var</span> myArray = [];

<span class="comment">// Adds "hello" on index 0</span>
myArray.push( <span class="string">"hello"</span> );

<span class="comment">// Adds "world" on index 1</span>
myArray.push( <span class="string">"world"</span> );

<span class="comment">// Adds "!" on index 2</span>
myArray[ <span class="number">2</span> ] = <span class="string">"!"</span>;</code></pre></div><p><code>.push()</code> 是一个函数，它扩展数组并添加一个元素到尾端。您也可以直接通过索引添加项。缺失的指数项将会被 <code>undefined</code> 填充。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Leaving indices</span>

<span class="keyword">var</span> myArray = [];

myArray[ <span class="number">0</span> ] = <span class="string">"hello"</span>;
myArray[ <span class="number">1</span> ] = <span class="string">"world"</span>;
myArray[ <span class="number">3</span> ] = <span class="string">"!"</span>;

console.log( myArray ); <span class="comment">// [ "hello", "world", undefined, "!" ];</span></code></pre></div><p>如果数组的大小是未知的，<code>.push()</code> 是更安全的。您可以通过索引取值或者赋值给数组项。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Accessing array items by index</span>

<span class="keyword">var</span> myArray = [ <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"!"</span> ];

console.log( myArray[ <span class="number">2</span> ] ); <span class="comment">// "!"</span></code></pre></div><h2 id="数组方法和属性">数组方法和属性</h2><h3 id="length">.length</h3><p><code>.length</code> 属性用于确定数组项的数量。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Length of an array</span>

<span class="keyword">var</span> myArray = [ <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"!"</span> ];

console.log( myArray.length ); <span class="comment">// 3</span></code></pre></div><p>您将需要 <code>.length</code> 属性用于遍历一个数组：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// For loops and arrays - a classic</span>

<span class="keyword">var</span> myArray = [ <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"!"</span> ];

<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; myArray.length; i = i + <span class="number">1</span> ) {

    console.log( myArray[ i ] );

}</code></pre></div><h3 id="concat">.concat()</h3><p>通过 <code>.concat()</code> 串联两个或多个数组：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> myArray = [ <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> ];
<span class="keyword">var</span> myOtherArray = [ <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> ];
<span class="keyword">var</span> wholeArray = myArray.concat( myOtherArray ); <span class="comment">// [ 2, 3, 4, 5, 6, 7 ]</span></code></pre></div><h3 id="join">.join()</h3><p><code>.join()</code> 使用一个分隔字符拼接数组的所有元素并创建数组的字符串表示。如果没有提供分隔符（即不带参数调用 <code>.join()</code>），数组会使用逗号进行拼接。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Joining elements</span>

<span class="keyword">var</span> myArray = [ <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"!"</span> ];

<span class="comment">// The default separator is a comma.</span>
console.log( myArray.join() );     <span class="comment">// "hello,world,!"</span>

<span class="comment">// Any string can be used as separator...</span>
console.log( myArray.join( <span class="string">" "</span> ) );  <span class="comment">// "hello world !";</span>
console.log( myArray.join( <span class="string">"!!"</span> ) ); <span class="comment">// "hello!!world!!!";</span>

<span class="comment">// ...including an empty one.</span>
console.log( myArray.join( <span class="string">""</span> ) );   <span class="comment">// "helloworld!"</span></code></pre></div><h3 id="pop">.pop()</h3><p><code>.pop()</code> 移除数组的最后一个元素。它是 <code>.push()</code> 的对立方法：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Pushing and popping</span>

<span class="keyword">var</span> myArray = [];

myArray.push( <span class="number">0</span> ); <span class="comment">// [ 0 ]</span>
myArray.push( <span class="number">2</span> ); <span class="comment">// [ 0 , 2 ]</span>
myArray.push( <span class="number">7</span> ); <span class="comment">// [ 0 , 2 , 7 ]</span>
myArray.pop();     <span class="comment">// [ 0 , 2 ]</span></code></pre></div><h3 id="reverse">.reverse()</h3><p>顾名思义，调用 <code>.reverse()</code> 方法后，数组中的元素按相反的顺序排列：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> myArray = [ <span class="string">"world"</span> , <span class="string">"hello"</span> ];
myArray.reverse(); <span class="comment">// [ "hello", "world" ]</span></code></pre></div><h3 id="shift">.shift()</h3><p>移除数组中的第一个元素。结合 <code>.push</code> 和 <code>.shift()</code>，你可以重建一个<a href="http://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97">队列</a>方法：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Queue with shift() and push()</span>

<span class="keyword">var</span> myArray = [];

myArray.push( <span class="number">0</span> ); <span class="comment">// [ 0 ]</span>
myArray.push( <span class="number">2</span> ); <span class="comment">// [ 0 , 2 ]</span>
myArray.push( <span class="number">7</span> ); <span class="comment">// [ 0 , 2 , 7 ]</span>
myArray.shift();   <span class="comment">// [ 2 , 7 ]</span></code></pre></div><h3 id="slice">.slice()</h3><p>提取数组的一部分，并返回一个包含该部分的新数组。这个方法需要一个参数，起始的索引：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Slicing</span>

<span class="keyword">var</span> myArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> ];
<span class="keyword">var</span> newArray = myArray.slice( <span class="number">3</span> );

console.log( myArray );  <span class="comment">// [ 1, 2, 3, 4, 5, 6, 7, 8 ]</span>
console.log( newArray ); <span class="comment">// [ 4, 5, 6, 7, 8 ]</span></code></pre></div><p><code>.slice()</code> 方法有一个可选的第二个参数，结束的索引。</p>
<div class="highlight"><pre><code class="javascript">console.log( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> ].slice( <span class="number">2</span>, <span class="number">5</span> ) ); <span class="comment">// [ 3, 4, 5 ]</span></code></pre></div><h3 id="splice">.splice()</h3><p>移除一个确定数量的元素并在给定的索引处开始添加新的元素。它至少需要三个参数：</p>
<div class="highlight"><pre><code class="javascript">myArray.splice( index, length, values, ... );</code></pre></div><ul>
<li><em>Index</em> – 开始的索引。</li>
<li><em>Length</em> – 移除的元素数量。</li>
<li><em>Values</em> – 在索引的位置插入的值。</li>
</ul>
<p>例如：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> myArray = [ <span class="number">0</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span> ];
myArray.splice( <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> );

console.log( myArray ); <span class="comment">// [ 0, 1, 2, 3, 4, 5 ]</span></code></pre></div><h3 id="sort">.sort()</h3><p>数组排序。它需要一个参数，一个比较函数。如果没有提供这个函数，数组默认按照升序进行排序：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Sorting without comparing function.</span>

<span class="keyword">var</span> myArray = [ <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span> ];

myArray.sort(); <span class="comment">// 1, 3, 4, 6</span></code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// Sorting with comparing function.</span>

<span class="function"><span class="keyword">function</span> <span class="title">descending</span><span class="params">( a, b )</span> {</span>
    <span class="keyword">return</span> b - a;
}

<span class="keyword">var</span> myArray = [ <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span> ];

myArray.sort( descending ); <span class="comment">// [ 6, 4, 3, 1 ]</span></code></pre></div><p>例子中的 <code>descending</code> 函数返回的值很重要。如果返回的值小于0，<code>a</code> 的位置在 <code>b</code> 之前，如果值大于0则位置相反。如果值等于0，则元素的位置（与当前）相同。</p>
<h3 id="unshift">.unshift()</h3><p>在数组的第一个位置插入一个元素：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> myArray = [];

myArray.unshift( <span class="number">0</span> ); <span class="comment">// [ 0 ]</span>
myArray.unshift( <span class="number">2</span> ); <span class="comment">// [ 2 , 0 ]</span>
myArray.unshift( <span class="number">7</span> ); <span class="comment">// [ 7 , 2 , 0 ]</span></code></pre></div><h3 id="foreach">.forEach()</h3><p>在现代浏览器中可以使用 <code>.forEach()</code> 方法遍历数组，您传递个这个方法的函数会被数组中的每个元素调用。</p>
<p>被传递的函数可以带三个参数：</p>
<ul>
<li><em>Element</em> – 元素本身。</li>
<li><em>Index</em> – 元素在数组中的索引。</li>
<li><em>Array</em> – 数组本身。</li>
</ul>
<p>所有的参数都是可选的，但你通常至少需要一个 <em>Element</em> 参数。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Native .forEach()</span>

<span class="function"><span class="keyword">function</span> <span class="title">printElement</span><span class="params">( elem )</span> {</span>
    console.log( elem );
}

<span class="function"><span class="keyword">function</span> <span class="title">printElementAndIndex</span><span class="params">( elem, index )</span> {</span>
    console.log( <span class="string">"Index "</span> + index + <span class="string">": "</span> + elem );
}

<span class="function"><span class="keyword">function</span> <span class="title">negateElement</span><span class="params">( elem, index, array )</span> {</span>
    array[ index ] = -elem;
}

myArray = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ];

<span class="comment">// Prints all elements to the console</span>
myArray.forEach( printElement );

<span class="comment">// Prints "Index 0: 1", "Index 1: 2", "Index 2: 3", ...</span>
myArray.forEach( printElementAndIndex );

<span class="comment">// myArray is now [ -1, -2, -3, -4, -5 ]</span>
myArray.forEach( negateElement );</code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[循环]]></title>
        <link href="http://101.js.org/javascript-101/loops.html"/>
        <published>2015-03-17T00:00:00.000Z</published>
        <updated>2015-03-17T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/loops.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>循环让一块代码运行一定的次数：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) {
    <span class="comment">// Logs "try 0", "try 1", ..., "try 4".</span>
    console.log( <span class="string">"try "</span> + i );
}</code></pre></div><p>需要注意的是在循环中，变量 <code>i</code> 的不仅仅作用于循环代码块，即使在变量名前使用了关键字 <code>var</code>。在<a href="/javascript-101/scope.html">作用域</a>部分将对作用域进行深入讨论。</p>
<h2 id="for-循环"><code>for</code> 循环</h2><p>一个 <code>for</code> 循环由四个语句组成，并具有以下结构：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">for</span> ( [initialization]; [conditional]; [iteration] ) {

    [loopBody]

}</code></pre></div><p>初始化语句（<em>initialization</em>）在循环开始前只执行一次。它是用来准备或声明任何变量的。</p>
<p>条件语句（<em>conditional</em>）在每次迭代之前执行，它会返回一个值用来判断循环是否继续。如果条件语句的计算结果为一个假值，则循环停止。</p>
<p>迭代语句（<em>iteration</em>）在每次迭代结束时执行，它给你一个机会来改变重要变量的状态。通常，这将涉及递增或递减一个计数器，从而使循环接近结束。</p>
<p>循环体语句（<em>loopBody</em>）是每一次循环执行的内容，它可以包含任何东西。通常，会有需要被执行的多行语句，并应包裹在一个代码块中（<code>{...}</code>）。</p>
<p>一个典型的 <code>for</code> 循环：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, limit = <span class="number">100</span>; i &lt; limit; i++) {
    <span class="comment">// This block will be executed 100 times.</span>
    console.log( <span class="string">"Currently at "</span> + i );
    <span class="comment">// Note: The last log will be "Currently at 99".</span>
}</code></pre></div><h2 id="for-in-循环"><code>for...in</code> 循环</h2><p>一个 <code>for...in</code> 循环遍历一个对象的属性，针对每一个属性，循环体语句可以被执行一次。</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">for</span> ( prop <span class="keyword">in</span> obj ) {
    <span class="comment">// statements here will be executed for every key in the object</span>
    console.log( prop + <span class="string">': '</span> + obj[ prop ] );
}</code></pre></div><h2 id="while-循环"><code>while</code> 循环</h2><p>一个 <code>while</code> 循环类似于一个 <code>if</code> 语句，不同之处在于它的主体部分会继续执行，直到条件语句计算结果为一个假值。</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">while</span> ( [conditional] ) {

    [loopBody]

}</code></pre></div><p>一个典型的 <code>while</code> 循环：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> i = <span class="number">0</span>;
<span class="keyword">while</span> ( i &lt; <span class="number">100</span> ) {
    <span class="comment">// This block will be executed 100 times.</span>
    console.log( <span class="string">"Currently at "</span> + i );
    i++; <span class="comment">// Increment i</span>
}</code></pre></div><p>需要注意的是计数器是在循环的主体部分递增的。将条件和增量合并也是可行的，像这样：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> i = -<span class="number">1</span>;
<span class="keyword">while</span> ( ++i &lt; <span class="number">100</span> ) {
    <span class="comment">// This block will be executed 100 times.</span>
    console.log( <span class="string">"Currently at "</span> + i );
}</code></pre></div><p>请注意计数器开始于－1，并使用前置增量符（<code>++i</code>）。</p>
<h2 id="do-while-循环"><code>do-while</code> 循环</h2><p>这几乎是与 <code>while</code> 循环完全一样的，不同的是实际上它的循环主体内容在条件测试之前至少会执行一次。</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">do</span> {

    [loopBody]

} <span class="keyword">while</span> ( [conditional] )</code></pre></div><p>一个 <code>do-while</code> 循环：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">do</span> {
    <span class="comment">// Even though the condition evaluates to false</span>
    <span class="comment">// this loop's body will still execute once.</span>
    alert( <span class="string">"Hi there!"</span> );

} <span class="keyword">while</span> ( <span class="literal">false</span> );</code></pre></div><p>这一类型的循环是少见的，因为只有极少数情况下需要盲目的执行一次循环。无论如何，意识到这一点就好。</p>
<h2 id="break-和-continue"><code>break</code> 和 <code>continue</code></h2><p>通常的，条件语句的计算结果不是一个真值会导致循环的终止，但是也可以通过循环内部的 <code>break</code> 语句将循环在其正常运行轨道期终止：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Stopping a loop</span>
<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) {
    <span class="keyword">if</span> ( something ) {
        <span class="keyword">break</span>;
    }
}</code></pre></div><p>你可能还需要继续循环，但不执行循环主体内的部分内容。这可以通过 <code>continue</code> 语句做到：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Skipping to the next iteration of a loop</span>
<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) {
    <span class="keyword">if</span> ( something ) {
        <span class="keyword">continue</span>;
    }

    <span class="comment">// The following statement will only be executed</span>
    <span class="comment">// if the conditional "something" has not been met</span>
    console.log( <span class="string">"I have been reached"</span> );

}</code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[运算符]]></title>
        <link href="http://101.js.org/javascript-101/operators.html"/>
        <published>2015-03-13T00:00:00.000Z</published>
        <updated>2015-03-13T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/operators.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>基本的运算符让你可以操作值。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Concatenation</span>
<span class="keyword">var</span> foo = <span class="string">"hello"</span>;
<span class="keyword">var</span> bar = <span class="string">"world"</span>;

console.log( foo + <span class="string">" "</span> + bar ); <span class="comment">// "hello world"</span></code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// Multiplication and division</span>
<span class="number">2</span> * <span class="number">3</span>;
<span class="number">2</span> / <span class="number">3</span>;</code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// Incrementing and decrementing</span>
<span class="comment">// The pre-increment operator increments the operand before any further processing.</span>
<span class="keyword">var</span> i = <span class="number">1</span>;
console.log( ++i ); <span class="comment">// 2 - because i was incremented before evaluation</span>
console.log( i );   <span class="comment">// 2</span>

<span class="comment">// The post-increment operator increments the operand after processing it.</span>
<span class="keyword">var</span> i = <span class="number">1</span>;
console.log( i++ ); <span class="comment">// 1 - because i was evaluated to 1 and _then_ incremented</span>
console.log( i );   <span class="comment">// 2 - incremented after using it</span></code></pre></div><h2 id="数字和字符串操作">数字和字符串操作</h2><p>在 JavaScript 中，数字和字符串偶尔会表现的出人意料。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Addition vs. Concatenation</span>
<span class="keyword">var</span> foo = <span class="number">1</span>;
<span class="keyword">var</span> bar = <span class="string">"2"</span>;

console.log( foo + bar ); <span class="comment">// "12"</span></code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// Coercing a string to act as a number.</span>
<span class="keyword">var</span> foo = <span class="number">1</span>;
<span class="keyword">var</span> bar = <span class="string">"2"</span>;

console.log( foo + Number(bar) ); <span class="comment">// 3</span></code></pre></div><p><code>Number</code> 构造函数被当作普通函数调用时（如上所示），会将传递给它的参数转换成数字。一元加号运算符也可以完成同样的功能：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Forcing a string to act as a number (using the unary plus operator).</span>
console.log( foo + +bar ); <span class="comment">// 3</span></code></pre></div><h2 id="逻辑运算符">逻辑运算符</h2><p>逻辑运算符允许通过与（<code>&amp;&amp;</code>）和或（<code>||</code>）运算符来对一系列的运算数进行运算。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Logical AND and OR operators</span>

<span class="keyword">var</span> foo = <span class="number">1</span>;
<span class="keyword">var</span> bar = <span class="number">0</span>;
<span class="keyword">var</span> baz = <span class="number">2</span>;

<span class="comment">// returns 1, which is true</span>
foo || bar;

<span class="comment">// returns 1, which is true</span>
bar || foo;

<span class="comment">// returns 0, which is false</span>
foo &amp;&amp; bar;

<span class="comment">// returns 2, which is true</span>
foo &amp;&amp; baz;

<span class="comment">// returns 1, which is true</span>
baz &amp;&amp; foo;</code></pre></div><p>在上面的例子中，<code>||</code> 运算符返回第一个真值运算数的值，或者在运算数都是真值的情况下返回最后一个运算数的值。<code>&amp;&amp;</code> 运算符返回第一个假值运算数的值，或者当运算数都是真值的情况下返回最后一个运算数的值。</p>
<p>通常你会看到开发者使用逻辑运算符来代替 <code>if</code> 语句进行流程控制。例如：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Do something with foo if foo is truthy.</span>
foo &amp;&amp; doSomething( foo );

<span class="comment">// Set bar to baz if baz is truthy;</span>
<span class="comment">// otherwise, set it to the return value of createBar()</span>
<span class="keyword">var</span> bar = baz || createBar();</code></pre></div><p>这种风格比较优雅和简洁，但是也可能难于阅读或使用，特别是对新手来说。在<a href="/javascript-101/conditional-code.html">条件代码</a>部分可查看更多关于真值和假值的事情。</p>
<h2 id="比较运算符">比较运算符</h2><p>比较运算符允许你来测试值是否相等或者是否相同。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Comparison operators</span>

<span class="keyword">var</span> foo = <span class="number">1</span>;
<span class="keyword">var</span> bar = <span class="number">0</span>;
<span class="keyword">var</span> baz = <span class="string">"1"</span>;
<span class="keyword">var</span> bim = <span class="number">2</span>;

foo == bar; <span class="comment">// false</span>
foo != bar; <span class="comment">// true</span>
foo == baz; <span class="comment">// true; but note that the types are different</span>

foo === baz;             <span class="comment">// false</span>
foo !== baz;             <span class="comment">// true</span>
foo === parseInt( baz ); <span class="comment">// true</span>

foo &gt; bim;  <span class="comment">// false</span>
bim &gt; baz;  <span class="comment">// true</span>
foo &lt;= baz; <span class="comment">// true</span></code></pre></div><p>有关比较运算符的更多信息，可访问<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Operators/Comparison_Operators" title="MDN - 比较运算符">Mozilla 开发者网络</a>。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[条件代码]]></title>
        <link href="http://101.js.org/javascript-101/conditional-code.html"/>
        <published>2015-03-11T00:00:00.000Z</published>
        <updated>2015-03-11T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/conditional-code.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>有时候一个代码块应该只在一定条件下运行。流程控制 － 通过 <code>if</code> 和 <code>else</code> 代码块，让你的代码只在满足一定的条件下运行。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Flow control</span>

<span class="keyword">var</span> foo = <span class="literal">true</span>;
<span class="keyword">var</span> bar = <span class="literal">false</span>;

<span class="keyword">if</span> ( bar ) {
    <span class="comment">// This code will never run.</span>
    console.log( <span class="string">"hello!"</span> );
}

<span class="keyword">if</span> ( bar ) {

    <span class="comment">// This code won't run.</span>

} <span class="keyword">else</span> {

    <span class="keyword">if</span> ( foo ) {
        <span class="comment">// This code will run.</span>
    } <span class="keyword">else</span> {
        <span class="comment">// This code would run if foo and bar were both false.</span>
    }

}</code></pre></div><p>虽然在单行 <code>if</code> 语句里，大括号不是必须的，但应该保持一致的使用它们，这样使得代码会更有可读性。</p>
<p>注意不要在 <code>if</code> 或 <code>else</code> 代码块中，多次定义相同名称的函数。因为这样做可能会得不到预期的结果。</p>
<h2 id="truthy-和-falsy">Truthy 和 Falsy</h2><p>为了成功的使用流程控制，重要的一点是需要理解哪些类型的值是“truthy”，哪些是“falsy”。有时候一个值实际计算的结果和看起来应该会得到的结果不同。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Values that evaluate to false:</span>
<span class="literal">false</span>
<span class="string">""</span> <span class="comment">// An empty string.</span>
<span class="literal">NaN</span> <span class="comment">// JavaScript's "not-a-number" variable.</span>
<span class="literal">null</span>
<span class="literal">undefined</span> <span class="comment">// Be careful -- undefined can be redefined!</span>
<span class="number">0</span> <span class="comment">// The number zero.</span></code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// Everything else evaluates to true, some examples:</span>
<span class="string">"0"</span>
<span class="string">"any string"</span>
[] <span class="comment">// An empty array.</span>
{} <span class="comment">// An empty object.</span>
<span class="number">1</span> <span class="comment">// Any non-zero number.</span></code></pre></div><h2 id="有条件的变量赋值与三元运算符">有条件的变量赋值与三元运算符</h2><p>有时一个变量要根据一些条件而设定。可以使用 <code>if</code> 或 <code>else</code> 语句，但在许多情况下，三元运算符更加方便。三元运算符测试一个条件，如果条件为真，则返回一个确定的值，否则返回一个不同的值。</p>
<p>三元运算符：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Set foo to 1 if bar is true; otherwise, set foo to 0:</span>
<span class="keyword">var</span> foo = bar ? <span class="number">1</span> : <span class="number">0</span>;</code></pre></div><p>虽然三元运算符可以在不将返回值赋值给变量的情况下使用，但这是不推荐的。</p>
<h2 id="switch-语句">switch 语句</h2><p>比起使用一系列的 <code>if</code> 或 <code>else</code> 代码块，有时使用一个 <code>switch</code> 语句替代会更有效。<code>switch</code> 语句查看一个变量或表达式的值，并根据不同的值执行不同的代码块。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// A switch statement</span>

<span class="keyword">switch</span> ( foo ) {

    <span class="keyword">case</span> <span class="string">"bar"</span>:
        alert( <span class="string">"the value was bar -- yay!"</span> );
        <span class="keyword">break</span>;

    <span class="keyword">case</span> <span class="string">"baz"</span>:
        alert( <span class="string">"boo baz :("</span> );
        <span class="keyword">break</span>;

    <span class="keyword">default</span>:
        alert( <span class="string">"everything else is just ok"</span> );

}</code></pre></div><p>在 JavaScript 中 switch 语句有些不太流行，因为同样的行为可以通过创建一个可重用和易测试的对象来完成。</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> stuffToDo = {

    <span class="string">"bar"</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert( <span class="string">"the value was bar -- yay!"</span> );
    },

    <span class="string">"baz"</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert( <span class="string">"boo baz :("</span> );
    },

    <span class="string">"default"</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert( <span class="string">"everything else is just ok"</span> );
    }

};

<span class="comment">// Check if the property exists in the object.</span>
<span class="keyword">if</span> ( stuffToDo[ foo ] ) {
    <span class="comment">// This code won't run.</span>
    stuffToDo[ foo ]();

} <span class="keyword">else</span> {
    <span class="comment">// This code will run.</span>
    stuffToDo[ <span class="string">"default"</span> ]();

}</code></pre></div><p>对象会在 <a href="/javascript-101/types.html">类型</a> 和 <a href="/javascript-101/objects.html">对象</a> 部分进一步讨论。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[类型测试]]></title>
        <link href="http://101.js.org/javascript-101/testing-type.html"/>
        <published>2015-03-09T00:00:00.000Z</published>
        <updated>2015-03-09T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/testing-type.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>JavaScript 提供了一种方法来测试变量的类型。然而，其结果可能会让人迷惑 － 例如，一个数组的类型是 <code>object</code>。</p>
<p>当试图检测一个特定值的类型时，常见的做法是使用 <code>typeof</code> 运算符。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Testing the type of various variables.</span>
<span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log( <span class="string">"hello"</span> );
};
<span class="keyword">var</span> myObject = {
    foo: <span class="string">"bar"</span>
};
<span class="keyword">var</span> myArray = [ <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> ];
<span class="keyword">var</span> myString = <span class="string">"hello"</span>;
<span class="keyword">var</span> myNumber = <span class="number">3</span>;
<span class="keyword">var</span> myRegExp = <span class="regexp">/(\w+)\s(\w+)/</span>;

<span class="keyword">typeof</span> myFunction; <span class="comment">// "function"</span>
<span class="keyword">typeof</span> myObject;   <span class="comment">// "object"</span>
<span class="keyword">typeof</span> myArray;    <span class="comment">// "object" -- Careful!</span>
<span class="keyword">typeof</span> myString;   <span class="comment">// "string"</span>
<span class="keyword">typeof</span> myNumber;   <span class="comment">// "number"</span>
<span class="keyword">typeof</span> <span class="literal">null</span>;       <span class="comment">// "object" -- Careful!</span>
<span class="keyword">typeof</span> <span class="literal">undefined</span>;  <span class="comment">// "undefined"</span>
<span class="keyword">typeof</span> meh;        <span class="comment">// "undefined" -- undefined variable.</span>
<span class="keyword">typeof</span> myRegExp;   <span class="comment">// "function" or "object" depending on environment.</span>


<span class="keyword">if</span> ( myArray.push &amp;&amp; myArray.slice &amp;&amp; myArray.join ) {
    <span class="comment">// probably an array (this is called "duck typing")</span>
}

<span class="keyword">if</span> ( Object.prototype.toString.call( myArray ) === <span class="string">"[object Array]"</span> ) {
    <span class="comment">// Definitely an array!</span>
    <span class="comment">// This is widely considered as the most robust way</span>
    <span class="comment">// to determine if a specific value is an Array.</span>
}</code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[类型]]></title>
        <link href="http://101.js.org/javascript-101/types.html"/>
        <published>2015-03-09T00:00:00.000Z</published>
        <updated>2015-03-09T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/types.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>JavaScript 中的数据类型有两类：原始类型和对象。原始类型包括：</p>
<ul>
<li>字符串</li>
<li>数字</li>
<li>布尔</li>
<li>null</li>
<li>undefined</li>
</ul>
<h2 id="字符串">字符串</h2><p>字符串是被单引号或双引号包含的文本。最佳实践是始终保持使用一种引号。有时候字符串里的引号标记会和创建字符串的引号冲突，在这种情况下，可以使用 <code>\</code> 反斜线转义字符或者使用不同的引号。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Strings can be created with double or single quotes.</span>
<span class="keyword">var</span> a = <span class="string">"I am a string"</span>;
<span class="keyword">var</span> b = <span class="string">'So am I!'</span>;
alert( a );
alert( b );</code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// Sometimes a string may contain quotation marks.</span>
<span class="keyword">var</span> statement1 = <span class="string">'He said "JavaScript is awesome!"'</span>;
<span class="keyword">var</span> statement2 = <span class="string">"He said \"JavaScript is awesome!\""</span>;</code></pre></div><h2 id="数字">数字</h2><p>数字是任何正或负的数值。整数和浮点数之间没有区别。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Numbers are any whole or floating point integer.</span>
<span class="keyword">var</span> num1 = <span class="number">100</span>;
<span class="keyword">var</span> num2 = <span class="number">100.10</span>;
<span class="keyword">var</span> num3 = <span class="number">0.10</span>;</code></pre></div><h2 id="布尔">布尔</h2><p>布尔类型是 <code>true</code> 或者 <code>false</code>。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Boolean values.</span>
<span class="keyword">var</span> okay = <span class="literal">true</span>;
<span class="keyword">var</span> fail = <span class="literal">false</span>;</code></pre></div><h2 id="null-和-undefined">null 和 undefined</h2><p><code>null</code> 和 <code>undefined</code> 是 JavaScript 中的特殊类型。 Null 类型表示一个空值，类似于许多其他语言。 Undefined 类型表示变量还没有赋值的状态，可以通过两种方式来创建： 通过使用 <code>undefined</code> 关键字或者在定义变量的时候不赋值。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Define a null value.</span>
<span class="keyword">var</span> foo = <span class="literal">null</span>;

<span class="comment">// Two ways to achieve an undefined value.</span>
<span class="keyword">var</span> bar1 = <span class="literal">undefined</span>;
<span class="keyword">var</span> bar2;</code></pre></div><h2 id="对象">对象</h2><p>其他一切都是对象。JavaScript 有众多的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" title="MDN - 内置对象">内置对象</a>，但本指南只包括：</p>
<ul>
<li>对象</li>
<li>数组</li>
<li>函数</li>
</ul>
<p>最简单的创建对象的方法是被称为对象字面量的简写语法。这些简单的对象是无序的键值对集合。对象中的键通常被称为“属性”，属性的值可以是任何有效的 JavaScript 类型，甚至可以是另一个对象。创建或访问对象的属性，我们可以使用“点号表示法”或者“括号表示法”。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Using an empty object literal</span>
<span class="keyword">var</span> person1 = {};

<span class="comment">// Assign properties using "dot notation"</span>
person1.firstName = <span class="string">"John"</span>;
person1.lastName = <span class="string">"Doe"</span>;

<span class="comment">// Access properties using "dot notation"</span>
alert( person1.firstName + <span class="string">" "</span> + person1.lastName );

<span class="comment">// Creating an object with the object literal syntax:</span>
<span class="keyword">var</span> person2 = {
    firstName: <span class="string">"Jane"</span>,
    lastName: <span class="string">"Doe"</span>
};

alert( person2.firstName + <span class="string">" "</span> + person2.lastName );

<span class="keyword">var</span> people = {};

<span class="comment">// Assign properties using "bracket notation"</span>
<span class="comment">// As mentioned, objects can also have objects as a property value</span>
people[ <span class="string">"person1"</span> ] = person1;
people[ <span class="string">"person2"</span> ] = person2;

<span class="comment">// Access properties using a mix of both bracket and dot notation</span>
alert( people[ <span class="string">"person1"</span> ].firstName );
alert( people[ <span class="string">"person2"</span> ].firstName );</code></pre></div><p>如果被访问的属性还未定义，那么它的值将是 <code>undefined</code>。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Properties that have not been created are undefined.</span>
<span class="keyword">var</span> person = { name: <span class="string">"John Doe"</span> };
alert( person.email ); <span class="comment">// undefined</span></code></pre></div><p>在 <a href="/javascript-101/objects.html">对象</a> 部分会进一步讨论 JavaScript 对象。</p>
<h2 id="数组">数组</h2><p>数组是一类由它所包含的每一个项的索引排序的对象。索引开始于零，并扩展到已添加的项的数目，（项的数目）也是被称为 <code>.length</code> 的数组属性。类似一个基本对象，数组可以使用 <code>Array</code> 构造函数或者被称为数组字面量的简写语法来创建。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Creating an array with the constructor:</span>
<span class="keyword">var</span> foo = <span class="keyword">new</span> Array;

<span class="comment">// Creating an array with the array literal syntax:</span>
<span class="keyword">var</span> bar = [];</code></pre></div><p>在这两种语法之间有一个重要的区别。数组构造函数和数组字面量都可以在创建时加入要包含到数组的项，但是如果只是传入一个单一的数字项，数组构造函数会将该数字项当作数组的长度值。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// The array literal returns a foo.length value of 1:</span>
<span class="keyword">var</span> foo = [ <span class="number">100</span> ];
alert( foo[ <span class="number">0</span> ] ); <span class="comment">// 100</span>
alert( foo.length ); <span class="comment">// 1</span>

<span class="comment">// The array constructor returns a bar.length value of 100:</span>
<span class="keyword">var</span> bar = <span class="keyword">new</span> Array( <span class="number">100</span> );
alert( bar[ <span class="number">0</span> ] ); <span class="comment">// undefined</span>
alert( bar.length ); <span class="comment">// 100</span></code></pre></div><p>数组可以通过已经存在数组实例中的方法来进行相关操作。数组中的项可以通过括号和给定的索引来引用。如果索引不存在或者不包括任何值，则返回值 <code>undefined</code>。</p>
<p>一些常见的数组方法如下所示：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Using the push(), pop(), unshift() and shift() methods on an array.</span>

<span class="keyword">var</span> foo = [];

foo.push( <span class="string">"a"</span> );
foo.push( <span class="string">"b"</span> );

alert( foo[ <span class="number">0</span> ] ); <span class="comment">// a</span>
alert( foo[ <span class="number">1</span> ] ); <span class="comment">// b</span>

alert( foo.length ); <span class="comment">// 2</span>

foo.pop();

alert( foo[ <span class="number">0</span> ] ); <span class="comment">// a</span>
alert( foo[ <span class="number">1</span> ] ); <span class="comment">// undefined</span>

alert( foo.length ); <span class="comment">// 1</span>

foo.unshift( <span class="string">"z"</span> );

alert( foo[ <span class="number">0</span> ] ); <span class="comment">// z</span>
alert( foo[ <span class="number">1</span> ] ); <span class="comment">// a</span>

alert( foo.length ); <span class="comment">// 2</span>

foo.shift();

alert( foo[ <span class="number">0</span> ] ); <span class="comment">// a</span>
alert( foo[ <span class="number">1</span> ] ); <span class="comment">// undefined</span>

alert( foo.length ); <span class="comment">// 1</span></code></pre></div><p>还有更多的方法来操作数组，一部分将在<a href="/javascript-101/arrays.html">数组</a> 进一步讨论。更多的详细信息可在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" title="MDN - 数组参考">Mozilla 开发者网络</a> 找到。</p>
<h2 id="jquery-中的类型检测">jQuery 中的类型检测</h2><p>jQuery 提供了一些基本的实用方法，用于判断一个特定值的类型。类型检测会在 <a href="/javascript-101/testing-type.html">类型检测</a>部分进一步的讨论，这里有一些例子：</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Checking the type of an arbitrary value.</span>

<span class="keyword">var</span> myValue = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> ];

<span class="comment">// Using JavaScript's typeof operator to test for primitive types:</span>
<span class="keyword">typeof</span> myValue === <span class="string">"string"</span>; <span class="comment">// false</span>
<span class="keyword">typeof</span> myValue === <span class="string">"number"</span>; <span class="comment">// false</span>
<span class="keyword">typeof</span> myValue === <span class="string">"undefined"</span>; <span class="comment">// false</span>
<span class="keyword">typeof</span> myValue === <span class="string">"boolean"</span>; <span class="comment">// false</span>

<span class="comment">// Using strict equality operator to check for null:</span>
myValue === <span class="literal">null</span>; <span class="comment">// false</span>

<span class="comment">// Using jQuery's methods to check for non-primitive types:</span>
jQuery.isFunction( myValue ); <span class="comment">// false</span>
jQuery.isPlainObject( myValue ); <span class="comment">// false</span>
jQuery.isArray( myValue ); <span class="comment">// true</span></code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[保留字]]></title>
        <link href="http://101.js.org/javascript-101/reserved-words.html"/>
        <published>2015-03-06T00:00:00.000Z</published>
        <updated>2015-03-06T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/reserved-words.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>JavaScript 有一些“保留字”，或有特殊意义的单词。除非你按照它们的本意来使用，否则你应该避免在代码中使用这些字词。</p>
<ul>
<li><code>break</code></li>
<li><code>case</code></li>
<li><code>catch</code></li>
<li><code>class</code></li>
<li><code>const</code></li>
<li><code>continue</code></li>
<li><code>debugger</code></li>
<li><code>default</code></li>
<li><code>delete</code></li>
<li><code>do</code></li>
<li><code>else</code></li>
<li><code>enum</code></li>
<li><code>export</code></li>
<li><code>extends</code></li>
<li><code>false</code></li>
<li><code>finally</code></li>
<li><code>for</code></li>
<li><code>function</code></li>
<li><code>if</code></li>
<li><code>implements</code></li>
<li><code>import</code></li>
<li><code>in</code></li>
<li><code>instanceof</code></li>
<li><code>interface</code></li>
<li><code>let</code></li>
<li><code>new</code></li>
<li><code>null</code></li>
<li><code>package</code></li>
<li><code>private</code></li>
<li><code>protected</code></li>
<li><code>public</code></li>
<li><code>return</code></li>
<li><code>static</code></li>
<li><code>super</code></li>
<li><code>switch</code></li>
<li><code>this</code></li>
<li><code>throw</code></li>
<li><code>true</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>var</code></li>
<li><code>void</code></li>
<li><code>while</code></li>
<li><code>with</code></li>
<li><code>yield</code></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[语法基础]]></title>
        <link href="http://101.js.org/javascript-101/syntax-basics.html"/>
        <published>2015-03-06T00:00:00.000Z</published>
        <updated>2015-03-06T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/syntax-basics.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <h3 id="注释">注释</h3><p>JavaScript 支持单行和多行注释。注释会被 JavaScript 引擎忽略，所以它对程序的结果没有影响。使用注释为其他开发者记录代码，像 <a href="http://usejsdoc.org/" title="JSDoc">JSDoc</a> 这类工具库，可以帮助生成基于注释的项目文档页面。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Single- and multi-line comments.</span>

<span class="comment">// This is an example of a single-line comment.</span>

<span class="comment">/*
 * this is an example
 * of a
 * multi-line
 * comment.
 */</span></code></pre></div><h3 id="空白">空白</h3><p>空白也被 JavaScript 引擎忽略。有许多工具可以用来去掉程序中的空白，降低了文件的整体大小和改进网络延迟。鉴于这类工具的可用性，空白应该加以利用，以使代码尽可能的易读。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Whitespace is insignificant.</span>
<span class="keyword">var</span> hello = <span class="string">"Hello"</span>;
<span class="keyword">var</span> world     =      <span class="string">"World!"</span>;</code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// Semantic whitespace promotes readability.</span>
<span class="comment">// Readable code is good!</span>
<span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) {

        alert( i );

    }

};

foo();

<span class="comment">// This is much harder to read!</span>
<span class="keyword">var</span> foo=<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){alert(i);}};foo();</code></pre></div><h3 id="保留字">保留字</h3><p>当声明用户定义的变量和函数时，有少量的保留字不能被使用。一些保留字已经被实现，一些被保留以供将来使用，还有一些事因为历史原因而保留。<a href="/javascript-101/reserved-words.html">这里</a>是保留字的列表，对保留字的深入解释可以在<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Reserved_Words" title="MDN 保留字"> MDN 的 JavaScript 参考</a>当中找到。</p>
<h3 id="标识符">标识符</h3><p>标识符被用来给变量和函数的唯一名称，以便随后它们可以通过该名称被引用到。标识符名称必须遵循一些规则：</p>
<ul>
<li>不能是保留字。</li>
<li>只能由字母，数字，美元符号和下划线组成。</li>
<li>第一个字符不能是数字。</li>
</ul>
<p>命名标识符的最佳实践是选取一个将来也能对你或者其他开发者有意义的名称。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Valid identifier names.</span>
<span class="keyword">var</span> myAwesomeVariable = <span class="string">"a"</span>;
<span class="keyword">var</span> myAwesomeVariable2 = <span class="string">"b"</span>;
<span class="keyword">var</span> my_awesome_variable = <span class="string">"c"</span>;
<span class="keyword">var</span> $my_AwesomeVariable = <span class="string">"d"</span>;
<span class="keyword">var</span> _my_awesome_variable_$ = <span class="string">"e"</span>;</code></pre></div><h3 id="变量定义">变量定义</h3><p>变量可以使用多个 <code>var</code> 语句来定义，或者使用单个组合的 <code>var</code> 语句。</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// This works:</span>
<span class="keyword">var</span> test = <span class="number">1</span>;
<span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> ... };
<span class="keyword">var</span> test3 = test2( test );

<span class="comment">// And so does this:</span>
<span class="keyword">var</span> test4 = <span class="number">1</span>,
    test5 = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span> ... },
    test6 = test2( test );</code></pre></div><p>变量可以在声明时不分配一个值，程序会给它们一个默认的值 <code>undefined</code>。</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> x;
x === <span class="literal">undefined</span>; <span class="comment">// true</span></code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[运行代码]]></title>
        <link href="http://101.js.org/javascript-101/running-code.html"/>
        <published>2015-03-03T00:00:00.000Z</published>
        <updated>2015-03-03T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/running-code.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <h3 id="外部">外部</h3><p>第一种也是推荐的方式是在一个外部文件（带有 <code>.js</code> 扩展名）编写代码，然后可以使用 HTML <code>script</code> 元素并通过 <code>src</code> 属性指定文件的位置来引入到网页中。当你需要将代码重复使用在其他页面时，保持 JavaScript 在一个单独的文件中可以减少代码的重复。另外它也可以让浏览器将文件缓存到客户端的计算机上，减少网页加载时间。</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- Code is written in a .js file, included via the script tag src attribute. --&gt;</span>
<span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"/path/to/example.js"</span>&gt;</span><span class="javascript"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><h3 id="内嵌">内嵌</h3><p>第二种方式是直接将代码内嵌在网页中。它也是通过 HTML <code>script</code> 元素实现，但不是通过 <code>src</code> 属性指定一个文件，而是将代码放置在元素中间。虽然有些情况下可以使用这种方式，但大部分时间，最好是如上所述将我们的代码放置在外部文件中。</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- Embed code directly on a web page using script tags. --&gt;</span>
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
alert( <span class="string">"Hello World!"</span> );
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></code></pre></div><h3 id="属性">属性</h3><p>最后一个选择是使用 HTML 元素的事件处理程序属性。这种方式是强烈不推荐的：</p>
<div class="highlight"><pre><code class="xml"><span class="comment">&lt;!-- Inline code directly on HTML elements being clicked. --&gt;</span>
<span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"javascript:alert( 'Hello World' );"</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="title">a</span>&gt;</span>
<span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">"alert( 'Good Bye World' );"</span>&gt;</span>Click Me Too!<span class="tag">&lt;/<span class="title">button</span>&gt;</span></code></pre></div><h3 id="位置">位置</h3><p>在上面的前两个方式中，代码的位置是重要的，并且需要根据情况而改变。如果你添加不访问页面元素的 JavaScript，你可以放心的把脚本放在 HTML <code>&lt;/head&gt;</code> 之前。但是，如果代码将与页面上的元素交互，就必须确保在执行代码时这些元素已经存在了。可以在下面的例子中看到这个常见的陷阱，一段查找 ID 为 <code>hello-world</code> 的元素脚本将会在页面定义元素之前执行。</p>
<div class="highlight"><pre><code class="xml"><span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
    <span class="comment">// Attempting to access an element too early will have unexpected results.</span>
    <span class="keyword">var</span> title = document.getElementById( <span class="string">"hello-world"</span> );
    console.log( title );
    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>

<span class="tag">&lt;<span class="title">h1</span> <span class="attribute">id</span>=<span class="value">"hello-world"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>

<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></code></pre></div><p>一个常见的模式是将脚本移动到页面的底部，HTML <code>&lt;/body&gt;</code> 前。这可以保证当执行代码时，元素已经在页面中定义了：</p>
<div class="highlight"><pre><code class="xml"><span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>

<span class="tag">&lt;<span class="title">h1</span> <span class="attribute">id</span>=<span class="value">"hello-world"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
<span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">
<span class="comment">// Moving the script to the bottom of the page will make sure the element exists.</span>
<span class="keyword">var</span> title = document.getElementById( <span class="string">"hello-world"</span> );
console.log( title );
</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>

<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></code></pre></div>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[入门]]></title>
        <link href="http://101.js.org/javascript-101/getting-started.html"/>
        <published>2015-02-28T00:00:00.000Z</published>
        <updated>2015-02-28T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/getting-started.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <h2 id="网页的解剖学">网页的解剖学</h2><p>在深入 JavaScript 之前，对网页的解剖有助于理解 JavaScript 是如何与其他网络技术密切合作的。</p>
<h2 id="html-是内容">HTML 是内容</h2><p>HTML 是用来定义和描述内容的标记语言。无论是博客文章，搜索引擎结果，或者电商网站，网页的核心内容都是用 HTML 编写的。语义标记是指 HTML 中用来描述内容的通用术语（头部，段落，图片等）。</p>
<h2 id="css-是表现">CSS 是表现</h2><p>CSS 是一个为 HTML 文档应用样式的附加语言。CSS 的全部都是关于如何通过定义字体，颜色等其他视觉美感，让内容更好看。CSS 的强大之处在于样式不再和内容夹杂，这意味着你可以将不同的样式应用到同一块内容，当构建良好的跨设备响应式网站时，这是至关重要的。</p>
<h2 id="javascript-是交互">JavaScript 是交互</h2><p>在浏览器中，JavaScript 为 HTML 内容添加交互性和行为能力。没有 JavaScript，网页将会是静态和无聊的。JavaScript 使网页富有生命力。</p>
<p>看下面这个包含了 CSS 和 JavaScript 的简单 HTML 页面，了解这一切是如何组织在一起的：</p>
<div class="highlight"><pre><code class="xml"><span class="doctype">&lt;!doctype html&gt;</span>
<span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span>
<span class="tag">&lt;<span class="title">head</span>&gt;</span>
    <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"utf-8"</span> /&gt;</span>
    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="title">title</span>&gt;</span>

    <span class="comment">&lt;!-- CSS for presentation. --&gt;</span>
    <span class="tag">&lt;<span class="title">style</span>&gt;</span><span class="css">
    <span class="tag">h1</span> <span class="rules">{ <span class="rule"><span class="attribute">font-size</span>:<span class="value"> <span class="number">14</span>px</span></span>; <span class="rule"><span class="attribute">color</span>:<span class="value"> hotpink</span></span>; <span class="rule">}</span></span>
    <span class="tag">button</span> <span class="rules">{ <span class="rule"><span class="attribute">color</span>:<span class="value"> red</span></span>; <span class="rule">}</span></span>
    </span><span class="tag">&lt;/<span class="title">style</span>&gt;</span>
<span class="tag">&lt;/<span class="title">head</span>&gt;</span>
<span class="tag">&lt;<span class="title">body</span>&gt;</span>
    <span class="tag">&lt;<span class="title">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="title">h1</span>&gt;</span>
    <span class="tag">&lt;<span class="title">button</span>&gt;</span>Click Me!<span class="tag">&lt;/<span class="title">button</span>&gt;</span>

    <span class="comment">&lt;!-- JavaScript for interactivity. --&gt;</span>
    <span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript">

    <span class="comment">// Get a handle on the first button element in the document.</span>
    <span class="keyword">var</span> button = document.querySelector( <span class="string">"button"</span> );

    <span class="comment">// If a user clicks on it, say hello!</span>
    button.addEventListener( <span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">( ev )</span> {</span>
        alert( <span class="string">"Hello"</span> );
    }, <span class="literal">false</span>);

    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span>
<span class="tag">&lt;/<span class="title">body</span>&gt;</span>
<span class="tag">&lt;/<span class="title">html</span>&gt;</span></code></pre></div><p>在上面的例子中，HTML 是用来描述内容，“Hello World” 文本被 <code>h1</code> 元素描述为一个标题，“Click Me!” 被 <code>button</code> 元素描述为一个按钮。<code>style</code> 代码块包含了改变标题颜色和字体大小的 CSS。<code>script</code> 代码块包含了给按钮添加交互的 JavaScript。当用户点击这个按钮，会弹出一个显示“Hello”的警告信息。</p>
<h2 id="web-的脚本语言">Web 的脚本语言</h2><p>JavaScript 最初设计为网页添加交互性，而不是成为一个通用语言，所以它被设计为脚本语言。<a href="http://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a> 被认为是比通用语言更高效，因为它们是为特定的领域（如 JavaScript 为网络浏览器）而优化。然而，最近的技术发展让 JavaScript 在服务器端大热（通过 <a href="http://nodejs.org/">Node.js</a>），所以它现在也可以用于代替 PHP，Ruby 或者 ASP 等语言。本指南将专注于在浏览器中运行的 JavaScript。</p>
<p>“JavaScript” 这个名字有点误导性。尽管有相似的名字，但是 JavaScript 与 <a href="https://zh.wikipedia.org/wiki/Java">Java</a>（一种通用语言）没有任何关系。JavaScript 是基于开放式网络标准 ECMAScript。基于标准的语言不是任何一个实体或公司控制的－相反的，开发商们共同制定语言，这就是为什么 JavaScript 运行在每一个 Web 浏览器中，而无关操作系统或设备。</p>
<h2 id="你需要什么来开始学习-javascript-和-jquery">你需要什么来开始学习 JavaScript 和 jQuery</h2><ol>
<li>Web 浏览器</li>
<li>文本编辑器</li>
<li>开发者工具 (可选项)</li>
</ol>
<p>JavaScript 的最大优势之一是它的简单。它可以在任何操作系统上编写和运行，唯一的要求是一个网络浏览器和文本编辑器。也有许多工具可以让 JavaScript 开发更有效率，但它们是完全可选的。</p>
<h2 id="开发者工具">开发者工具</h2><p>许多浏览器附带的内置功能，通常被称为“开发者工具”，它提供了更好的视角来观察运行在浏览器里的 JavaScript 和 jQuery。虽然不是必须的，但当你调试代码错误时，你会发现开发者工具很有用。看看常见的浏览器开发者工具：</p>
<ul>
<li><a href="https://developer.apple.com/cn/technologies/safari/developer-tools.html">Safari 开发者工具</a></li>
<li><a href="https://developers.google.com/chrome-developer-tools/">Google Chrome Developer Tools</a></li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/ie/gg589507.aspx">IE 开发者工具</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Tools">火狐开发者工具</a></li>
<li><a href="http://www.opera.com/dragonfly/">Opera Dragonfly</a></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[this 关键字]]></title>
        <link href="http://101.js.org/javascript-101/this-keyword.html"/>
        <published>2014-04-12T00:00:00.000Z</published>
        <updated>2014-04-12T00:00:00.000Z</updated>
        <id>http://101.js.org/javascript-101/this-keyword.html</id>
        <content type="html" xml:base="http://101.js.org/" xml:lang="en">
            <![CDATA[ <p>在 JavaScript 中，如同在大部分面向对象编程语言中一样，<code>this</code> 是一个特殊的关键字，它常在被某个对象调用的方法中指向对象本身。<code>this</code> 的值可通过一系列简单的步骤来确定：</p>
<ul>
<li>如果函数是通过 <code>Function.call()</code> 或者 <code>Function.apply()</code> 调用，<code>this</code> 的值将会被设置为传递给 <code>.call()</code> 或 <code>.apply()</code> 的第一个参数。如果传递给 <code>.call()</code> 或 <code>.apply()</code> 的第一个参数是 <code>null</code> 或 <code>undefined</code>，<code>this</code> 会指向全局对象（在 Web 浏览器中是 <code>window</code> 对象）。</li>
<li>如果被调用的函数是由 <code>Function.bind()</code> 创建的，<code>this</code> 将会是该函数被创建时传递给 <code>.bind()</code> 的第一个参数。</li>
<li>如果函数是作为一个对象的方法被调用，<code>this</code> 将会指向那个对象。</li>
<li>否则，当函数作为一个不依附任何对象的独立函数被调用，<code>this</code> 会指向全局对象。</li>
</ul>
<div class="highlight"><pre><code class="javascript"><span class="comment">// A function invoked using Function.call()</span>

<span class="keyword">var</span> myObject = {
    sayHello: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        console.log( <span class="string">"Hi! My name is "</span> + <span class="keyword">this</span>.myName );
    },
    myName: <span class="string">"Rebecca"</span>
};

<span class="keyword">var</span> secondObject = {
    myName: <span class="string">"Colin"</span>
};

myObject.sayHello();                    <span class="comment">// "Hi! My name is Rebecca"</span>
myObject.sayHello.call( secondObject ); <span class="comment">// "Hi! My name is Colin"</span></code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// A function created using Function.bind()</span>

<span class="keyword">var</span> myName = <span class="string">"the global object"</span>;
<span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log( <span class="string">"Hi! My name is "</span> + <span class="keyword">this</span>.myName );
};
<span class="keyword">var</span> myObject = {
    myName: <span class="string">"Rebecca"</span>
};
<span class="keyword">var</span> myObjectHello = sayHello.bind( myObject );

sayHello();      <span class="comment">// "Hi! My name is the global object"</span>
myObjectHello(); <span class="comment">// "Hi! My name is Rebecca"</span></code></pre></div><div class="highlight"><pre><code class="javascript"><span class="comment">// A function being attached to an object at runtime.</span>

<span class="keyword">var</span> myName = <span class="string">"the global object"</span>;
<span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    console.log( <span class="string">"Hi! My name is "</span> + <span class="keyword">this</span>.myName );
};
<span class="keyword">var</span> myObject = {
    myName: <span class="string">"Rebecca"</span>
};
<span class="keyword">var</span> secondObject = {
    myName: <span class="string">"Colin"</span>
};

myObject.sayHello = sayHello;
secondObject.sayHello = sayHello;

sayHello();              <span class="comment">// "Hi! My name is the global object"</span>
myObject.sayHello();     <span class="comment">// "Hi! My name is Rebecca"</span>
secondObject.sayHello(); <span class="comment">// "Hi! My name is Colin"</span></code></pre></div><p>当深度调用一个长命名空间的函数时，它通常会诱使你使用一个单一简短的变量来引用实际的函数，以减少你所需要键入的代码。重点是实例方法不能这么做，因为这会导致函数内的 <code>this</code> 值发生改变，从而导致不正确的结果。例如：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> myNamespace = {
    myObject: {
        sayHello: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log( <span class="string">"Hi! My name is "</span> + <span class="keyword">this</span>.myName );
        },
        myName: <span class="string">"Rebecca"</span>
    }
};

<span class="keyword">var</span> hello = myNamespace.myObject.sayHello;

hello(); <span class="comment">// "Hi! My name is undefined"</span></code></pre></div><p>但是，你可以安全的减少所有代码，直到方法被调用的那个对象：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> myNamespace = {
    myObject: {
        sayHello: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
            console.log( <span class="string">"Hi! My name is "</span> + <span class="keyword">this</span>.myName );
        },
        myName: <span class="string">"Rebecca"</span>
    }
};

<span class="keyword">var</span> obj = myNamespace.myObject;

obj.sayHello(); <span class="comment">// "Hi! My name is Rebecca"</span></code></pre></div>]]>
        </content>
    </entry>
</feed>