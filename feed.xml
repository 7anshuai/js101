<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>JS101</title>
    <link href="http://js101.co/feed.xml" rel="self" />
    <link href="http://js101.co/" />
    <id>http://js101.co/feed.xml</id>
    <entry>
        <title type="html"><![CDATA[数组]]></title>
        <link href="http://js101.co/javascript-101/arrays.html"/>
        <published>2015-03-28T00:00:00.000Z</published>
        <updated>2015-03-28T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/arrays.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <p>数组是从零索引，值的有序列表。数组是一个简便的方式来存储一组相同类型的有关项（例如字符串），但实际上，一个数组可以包含多个类型的项，甚至是其他数组。</p>
<p>要创建一个数组，可以使用数组构造函数或者字面量声明式，在声明后，可以赋给变量一系列的值。</p>
<pre>// A simple array with constructor.
var myArray1 = new Array( &quot;hello&quot;, &quot;world&quot; );

// Literal declaration, the preferred way.
var myArray2 = [ &quot;hello&quot;, &quot;world&quot; ];</pre><p>字面量声明式通常是更好的选择。查看<a href="http://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml#Array_and_Object_literals">谷歌编码指南</a>可获得更多信息。</p>
<p>如果值是未知的，也可以创建一个空的数组，然后通过数组方法或者访问索引来添加元素：</p>
<pre>// Creating empty arrays and adding values

var myArray = [];

// Adds &quot;hello&quot; on index 0
myArray.push( &quot;hello&quot; );

// Adds &quot;world&quot; on index 1
myArray.push( &quot;world&quot; );

// Adds &quot;!&quot; on index 2
myArray[ 2 ] = &quot;!&quot;;</pre><p><code>.push()</code> 是一个函数，它扩展数组并添加一个元素到尾端。您也可以直接通过索引添加项。缺失的指数项将会被 <code>undefined</code> 填充。</p>
<pre>// Leaving indices

var myArray = [];

myArray[ 0 ] = &quot;hello&quot;;
myArray[ 1 ] = &quot;world&quot;;
myArray[ 3 ] = &quot;!&quot;;

console.log( myArray ); // [ &quot;hello&quot;, &quot;world&quot;, undefined, &quot;!&quot; ];</pre><p>如果数组的大小是未知的，<code>.push()</code> 是更安全的。您可以通过索引取值或者赋值给数组项。</p>
<pre>// Accessing array items by index

var myArray = [ &quot;hello&quot;, &quot;world&quot;, &quot;!&quot; ];

console.log( myArray[ 2 ] ); // &quot;!&quot;</pre><h2 id="数组方法和属性">数组方法和属性</h2><h3 id="length">.length</h3><p><code>.length</code> 属性用于确定数组项的数量。</p>
<pre>// Length of an array

var myArray = [ &quot;hello&quot;, &quot;world&quot;, &quot;!&quot; ];

console.log( myArray.length ); // 3</pre><p>您将需要 <code>.length</code> 属性用于遍历一个数组：</p>
<pre>// For loops and arrays - a classic

var myArray = [ &quot;hello&quot;, &quot;world&quot;, &quot;!&quot; ];

for ( var i = 0; i &lt; myArray.length; i = i + 1 ) {

    console.log( myArray[ i ] );

}</pre><h3 id="concat">.concat()</h3><p>通过 <code>.concat()</code> 串联两个或多个数组：</p>
<pre>var myArray = [ 2, 3, 4 ];
var myOtherArray = [ 5, 6, 7 ];
var wholeArray = myArray.concat( myOtherArray ); // [ 2, 3, 4, 5, 6, 7 ]</pre><h3 id="join">.join()</h3><p><code>.join()</code> 使用一个分隔字符拼接数组的所有元素并创建数组的字符串表示。如果没有提供分隔符（即不带参数调用 <code>.join()</code>），数组会使用逗号进行拼接。</p>
<pre>// Joining elements

var myArray = [ &quot;hello&quot;, &quot;world&quot;, &quot;!&quot; ];

// The default separator is a comma.
console.log( myArray.join() );     // &quot;hello,world,!&quot;

// Any string can be used as separator...
console.log( myArray.join( &quot; &quot; ) );  // &quot;hello world !&quot;;
console.log( myArray.join( &quot;!!&quot; ) ); // &quot;hello!!world!!!&quot;;

// ...including an empty one.
console.log( myArray.join( &quot;&quot; ) );   // &quot;helloworld!&quot;</pre><h3 id="pop">.pop()</h3><p><code>.pop()</code> 移除数组的最后一个元素。它是 <code>.push()</code> 的对立方法：</p>
<pre>// Pushing and popping

var myArray = [];

myArray.push( 0 ); // [ 0 ]
myArray.push( 2 ); // [ 0 , 2 ]
myArray.push( 7 ); // [ 0 , 2 , 7 ]
myArray.pop();     // [ 0 , 2 ]</pre><h3 id="reverse">.reverse()</h3><p>顾名思义，调用 <code>.reverse()</code> 方法后，数组中的元素按相反的顺序排列：</p>
<pre>var myArray = [ &quot;world&quot; , &quot;hello&quot; ];
myArray.reverse(); // [ &quot;hello&quot;, &quot;world&quot; ]</pre><h3 id="shift">.shift()</h3><p>移除数组中的第一个元素。结合 <code>.push</code> 和 <code>.shift()</code>，你可以重建一个<a href="http://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97">队列</a>方法：</p>
<pre>// Queue with shift() and push()

var myArray = [];

myArray.push( 0 ); // [ 0 ]
myArray.push( 2 ); // [ 0 , 2 ]
myArray.push( 7 ); // [ 0 , 2 , 7 ]
myArray.shift();   // [ 2 , 7 ]</pre><h3 id="slice">.slice()</h3><p>提取数组的一部分，并返回一个包含该部分的新数组。这个方法需要一个参数，起始的索引：</p>
<pre>// Slicing

var myArray = [ 1, 2, 3, 4, 5, 6, 7, 8 ];
var newArray = myArray.slice( 3 );

console.log( myArray );  // [ 1, 2, 3, 4, 5, 6, 7, 8 ]
console.log( newArray ); // [ 4, 5, 6, 7, 8 ]</pre><p><code>.slice()</code> 方法有一个可选的第二个参数，结束的索引。</p>
<pre>console.log( [ 1, 2, 3, 4, 5, 6, 7, 8 ].slice( 2, 5 ) ); // [ 3, 4, 5 ]</pre><h3 id="splice">.splice()</h3><p>移除一个确定数量的元素并在给定的索引处开始添加新的元素。它至少需要三个参数：</p>
<pre>myArray.splice( index, length, values, ... );</pre><ul>
<li><em>Index</em> – 开始的索引。</li>
<li><em>Length</em> – 移除的元素数量。</li>
<li><em>Values</em> – 在索引的位置插入的值。</li>
</ul>
<p>例如：</p>
<pre>var myArray = [ 0, 7, 8, 5 ];
myArray.splice( 1, 2, 1, 2, 3, 4 );

console.log( myArray ); // [ 0, 1, 2, 3, 4, 5 ]</pre><h3 id="sort">.sort()</h3><p>数组排序。它需要一个参数，一个比较函数。如果没有提供这个函数，数组默认按照升序进行排序：</p>
<pre>// Sorting without comparing function.

var myArray = [ 3, 4, 6, 1 ];

myArray.sort(); // 1, 3, 4, 6</pre><pre>// Sorting with comparing function.

function descending( a, b ) {
    return b - a;
}

var myArray = [ 3, 4, 6, 1 ];

myArray.sort( descending ); // [ 6, 4, 3, 1 ]</pre><p>例子中的 <code>descending</code> 函数返回的值很重要。如果返回的值小于0，<code>a</code> 的位置在 <code>b</code> 之前，如果值大于0则位置相反。如果值等于0，则元素的位置（与当前）相同。</p>
<h3 id="unshift">.unshift()</h3><p>在数组的第一个位置插入一个元素：</p>
<pre>var myArray = [];

myArray.unshift( 0 ); // [ 0 ]
myArray.unshift( 2 ); // [ 2 , 0 ]
myArray.unshift( 7 ); // [ 7 , 2 , 0 ]</pre><h3 id="foreach">.forEach()</h3><p>在现代浏览器中可以使用 <code>.forEach()</code> 方法遍历数组，您传递个这个方法的函数会被数组中的每个元素调用。</p>
<p>被传递的函数可以带三个参数：</p>
<ul>
<li><em>Element</em> – 元素本身。</li>
<li><em>Index</em> – 元素在数组中的索引。</li>
<li><em>Array</em> – 数组本身。</li>
</ul>
<p>所有的参数都是可选的，但你通常至少需要一个 <em>Element</em> 参数。</p>
<pre>// Native .forEach()

function printElement( elem ) {
    console.log( elem );
}

function printElementAndIndex( elem, index ) {
    console.log( &quot;Index &quot; + index + &quot;: &quot; + elem );
}

function negateElement( elem, index, array ) {
    array[ index ] = -elem;
}

myArray = [ 1, 2, 3, 4, 5 ];

// Prints all elements to the console
myArray.forEach( printElement );

// Prints &quot;Index 0: 1&quot;, &quot;Index 1: 2&quot;, &quot;Index 2: 3&quot;, ...
myArray.forEach( printElementAndIndex );

// myArray is now [ -1, -2, -3, -4, -5 ]
myArray.forEach( negateElement );</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[循环]]></title>
        <link href="http://js101.co/javascript-101/loops.html"/>
        <published>2015-03-17T00:00:00.000Z</published>
        <updated>2015-03-17T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/loops.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <p>循环让一块代码运行一定的次数：</p>
<pre>for ( var i = 0; i &lt; 5; i++ ) {
    // Logs &quot;try 0&quot;, &quot;try 1&quot;, ..., &quot;try 4&quot;.
    console.log( &quot;try &quot; + i );
}</pre><p>需要注意的是在循环中，变量 <code>i</code> 的不仅仅作用于循环代码块，即使在变量名前使用了关键字 <code>var</code>。在<a href="/javascript-101/scope.html">作用域</a>部分将对作用域进行深入讨论。</p>
<h2 id="for-循环"><code>for</code> 循环</h2><p>一个 <code>for</code> 循环由四个语句组成，并具有以下结构：</p>
<pre>for ( [initialization]; [conditional]; [iteration] ) {

    [loopBody]

}</pre><p>初始化语句（<em>initialization</em>）在循环开始前只执行一次。它是用来准备或声明任何变量的。</p>
<p>条件语句（<em>conditional</em>）在每次迭代之前执行，它会返回一个值用来判断循环是否继续。如果条件语句的计算结果为一个假值，则循环停止。</p>
<p>迭代语句（<em>iteration</em>）在每次迭代结束时执行，它给你一个机会来改变重要变量的状态。通常，这将涉及递增或递减一个计数器，从而使循环接近结束。</p>
<p>循环体语句（<em>loopBody</em>）是每一次循环执行的内容，它可以包含任何东西。通常，会有需要被执行的多行语句，并应包裹在一个代码块中（<code>{...}</code>）。</p>
<p>一个典型的 <code>for</code> 循环：</p>
<pre>for (var i = 0, limit = 100; i &lt; limit; i++) {
    // This block will be executed 100 times.
    console.log( &quot;Currently at &quot; + i );
    // Note: The last log will be &quot;Currently at 99&quot;.
}</pre><h2 id="for-in-循环"><code>for...in</code> 循环</h2><p>一个 <code>for...in</code> 循环遍历一个对象的属性，针对每一个属性，循环体语句可以被执行一次。</p>
<pre>for ( prop in obj ) {
    // statements here will be executed for every key in the object
    console.log( prop + &#39;: &#39; + obj[ prop ] );
}</pre><h2 id="while-循环"><code>while</code> 循环</h2><p>一个 <code>while</code> 循环类似于一个 <code>if</code> 语句，不同之处在于它的主体部分会继续执行，直到条件语句计算结果为一个假值。</p>
<pre>while ( [conditional] ) {

    [loopBody]

}</pre><p>一个典型的 <code>while</code> 循环：</p>
<pre>var i = 0;
while ( i &lt; 100 ) {
    // This block will be executed 100 times.
    console.log( &quot;Currently at &quot; + i );
    i++; // Increment i
}</pre><p>需要注意的是计数器是在循环的主体部分递增的。将条件和增量合并也是可行的，像这样：</p>
<pre>var i = -1;
while ( ++i &lt; 100 ) {
    // This block will be executed 100 times.
    console.log( &quot;Currently at &quot; + i );
}</pre><p>请注意计数器开始于－1，并使用前置增量符（<code>++i</code>）。</p>
<h2 id="do-while-循环"><code>do-while</code> 循环</h2><p>这几乎是与 <code>while</code> 循环完全一样的，不同的是实际上它的循环主体内容在条件测试之前至少会执行一次。</p>
<pre>do {

    [loopBody]

} while ( [conditional] )</pre><p>一个 <code>do-while</code> 循环：</p>
<pre>do {
    // Even though the condition evaluates to false
    // this loop&#39;s body will still execute once.
    alert( &quot;Hi there!&quot; );

} while ( false );</pre><p>这一类型的循环是少见的，因为只有极少数情况下需要盲目的执行一次循环。无论如何，意识到这一点就好。</p>
<h2 id="break-和-continue"><code>break</code> 和 <code>continue</code></h2><p>通常的，条件语句的计算结果不是一个真值会导致循环的终止，但是也可以通过循环内部的 <code>break</code> 语句将循环在其正常运行轨道期终止：</p>
<pre>// Stopping a loop
for ( var i = 0; i &lt; 10; i++ ) {
    if ( something ) {
        break;
    }
}</pre><p>你可能还需要继续循环，但不执行循环主体内的部分内容。这可以通过 <code>continue</code> 语句做到：</p>
<pre>// Skipping to the next iteration of a loop
for ( var i = 0; i &lt; 10; i++ ) {
    if ( something ) {
        continue;
    }

    // The following statement will only be executed
    // if the conditional &quot;something&quot; has not been met
    console.log( &quot;I have been reached&quot; );

}</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[运算符]]></title>
        <link href="http://js101.co/javascript-101/operators.html"/>
        <published>2015-03-13T00:00:00.000Z</published>
        <updated>2015-03-13T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/operators.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <p>基本的运算符让你可以操作值。</p>
<pre>// Concatenation
var foo = &quot;hello&quot;;
var bar = &quot;world&quot;;

console.log( foo + &quot; &quot; + bar ); // &quot;hello world&quot;</pre><pre>// Multiplication and division
2 * 3;
2 / 3;</pre><pre>// Incrementing and decrementing
// The pre-increment operator increments the operand before any further processing.
var i = 1;
console.log( ++i ); // 2 - because i was incremented before evaluation
console.log( i );   // 2

// The post-increment operator increments the operand after processing it.
var i = 1;
console.log( i++ ); // 1 - because i was evaluated to 1 and _then_ incremented
console.log( i );   // 2 - incremented after using it</pre><h2 id="数字和字符串操作">数字和字符串操作</h2><p>在 JavaScript 中，数字和字符串偶尔会表现的出人意料。</p>
<pre>// Addition vs. Concatenation
var foo = 1;
var bar = &quot;2&quot;;

console.log( foo + bar ); // &quot;12&quot;</pre><pre>// Coercing a string to act as a number.
var foo = 1;
var bar = &quot;2&quot;;

console.log( foo + Number(bar) ); // 3</pre><p><code>Number</code> 构造函数被当作普通函数调用时（如上所示），会将传递给它的参数转换成数字。一元加号运算符也可以完成同样的功能：</p>
<pre>// Forcing a string to act as a number (using the unary plus operator).
console.log( foo + +bar ); // 3</pre><h2 id="逻辑运算符">逻辑运算符</h2><p>逻辑运算符允许通过与（<code>&amp;&amp;</code>）和或（<code>||</code>）运算符来对一系列的运算数进行运算。</p>
<pre>// Logical AND and OR operators

var foo = 1;
var bar = 0;
var baz = 2;

// returns 1, which is true
foo || bar;

// returns 1, which is true
bar || foo;

// returns 0, which is false
foo && bar;

// returns 2, which is true
foo && baz;

// returns 1, which is true
baz && foo;</pre><p>在上面的例子中，<code>||</code> 运算符返回第一个真值运算数的值，或者在运算数都是真值的情况下返回最后一个运算数的值。<code>&amp;&amp;</code> 运算符返回第一个假值运算数的值，或者当运算数都是真值的情况下返回最后一个运算数的值。</p>
<p>通常你会看到开发者使用逻辑运算符来代替 <code>if</code> 语句进行流程控制。例如：</p>
<pre>// Do something with foo if foo is truthy.
foo && doSomething( foo );

// Set bar to baz if baz is truthy;
// otherwise, set it to the return value of createBar()
var bar = baz || createBar();</pre><p>这种风格比较优雅和简洁，但是也可能难于阅读或使用，特别是对新手来说。在<a href="/javascript-101/conditional-code.html">条件代码</a>部分可查看更多关于真值和假值的事情。</p>
<h2 id="比较运算符">比较运算符</h2><p>比较运算符允许你来测试值是否相等或者是否相同。</p>
<pre>// Comparison operators

var foo = 1;
var bar = 0;
var baz = &quot;1&quot;;
var bim = 2;

foo == bar; // false
foo != bar; // true
foo == baz; // true; but note that the types are different

foo === baz;             // false
foo !== baz;             // true
foo === parseInt( baz ); // true

foo &gt; bim;  // false
bim &gt; baz;  // true
foo &lt;= baz; // true</pre><p>有关比较运算符的更多信息，可访问<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Operators/Comparison_Operators" title="MDN - 比较运算符">Mozilla 开发者网络</a>。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[条件代码]]></title>
        <link href="http://js101.co/javascript-101/conditional-code.html"/>
        <published>2015-03-11T00:00:00.000Z</published>
        <updated>2015-03-11T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/conditional-code.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <p>有时候一个代码块应该只在一定条件下运行。流程控制 － 通过 <code>if</code> 和 <code>else</code> 代码块，让你的代码只在满足一定的条件下运行。</p>
<pre>// Flow control

var foo = true;
var bar = false;

if ( bar ) {
    // This code will never run.
    console.log( &quot;hello!&quot; );
}

if ( bar ) {

    // This code won&#39;t run.

} else {

    if ( foo ) {
        // This code will run.
    } else {
        // This code would run if foo and bar were both false.
    }

}</pre><p>虽然在单行 <code>if</code> 语句里，大括号不是必须的，但应该保持一致的使用它们，这样使得代码会更有可读性。</p>
<p>注意不要在 <code>if</code> 或 <code>else</code> 代码块中，多次定义相同名称的函数。因为这样做可能会得不到预期的结果。</p>
<h2 id="truthy-和-falsy">Truthy 和 Falsy</h2><p>为了成功的使用流程控制，重要的一点是需要理解哪些类型的值是“truthy”，哪些是“falsy”。有时候一个值实际计算的结果和看起来应该会得到的结果不同。</p>
<pre>// Values that evaluate to false:
false
&quot;&quot; // An empty string.
NaN // JavaScript&#39;s &quot;not-a-number&quot; variable.
null
undefined // Be careful -- undefined can be redefined!
0 // The number zero.</pre><pre>// Everything else evaluates to true, some examples:
&quot;0&quot;
&quot;any string&quot;
[] // An empty array.
{} // An empty object.
1 // Any non-zero number.</pre><h2 id="有条件的变量赋值与三元运算符">有条件的变量赋值与三元运算符</h2><p>有时一个变量要根据一些条件而设定。可以使用 <code>if</code> 或 <code>else</code> 语句，但在许多情况下，三元运算符更加方便。三元运算符测试一个条件，如果条件为真，则返回一个确定的值，否则返回一个不同的值。</p>
<p>三元运算符：</p>
<pre>// Set foo to 1 if bar is true; otherwise, set foo to 0:
var foo = bar ? 1 : 0;</pre><p>虽然三元运算符可以在不将返回值赋值给变量的情况下使用，但这是不推荐的。</p>
<h2 id="switch-语句">switch 语句</h2><p>比起使用一系列的 <code>if</code> 或 <code>else</code> 代码块，有时使用一个 <code>switch</code> 语句替代会更有效。<code>switch</code> 语句查看一个变量或表达式的值，并根据不同的值执行不同的代码块。</p>
<pre>// A switch statement

switch ( foo ) {

    case &quot;bar&quot;:
        alert( &quot;the value was bar -- yay!&quot; );
        break;

    case &quot;baz&quot;:
        alert( &quot;boo baz :(&quot; );
        break;

    default:
        alert( &quot;everything else is just ok&quot; );

}</pre><p>在 JavaScript 中 switch 语句有些不太流行，因为同样的行为可以通过创建一个可重用和易测试的对象来完成。</p>
<pre>var stuffToDo = {

    &quot;bar&quot;: function() {
        alert( &quot;the value was bar -- yay!&quot; );
    },

    &quot;baz&quot;: function() {
        alert( &quot;boo baz :(&quot; );
    },

    &quot;default&quot;: function() {
        alert( &quot;everything else is just ok&quot; );
    }

};

// Check if the property exists in the object.
if ( stuffToDo[ foo ] ) {
    // This code won&#39;t run.
    stuffToDo[ foo ]();

} else {
    // This code will run.
    stuffToDo[ &quot;default&quot; ]();

}</pre><p>对象会在 <a href="/javascript-101/types.html">类型</a> 和 <a href="/javascript-101/objects.html">对象</a> 部分进一步讨论。</p>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[类型测试]]></title>
        <link href="http://js101.co/javascript-101/testing-type.html"/>
        <published>2015-03-09T00:00:00.000Z</published>
        <updated>2015-03-09T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/testing-type.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <p>JavaScript 提供了一种方法来测试变量的类型。然而，其结果可能会让人迷惑 － 例如，一个数组的类型是 <code>object</code>。</p>
<p>当试图检测一个特定值的类型时，常见的做法是使用 <code>typeof</code> 运算符。</p>
<pre>// Testing the type of various variables.
var myFunction = function() {
    console.log( &quot;hello&quot; );
};
var myObject = {
    foo: &quot;bar&quot;
};
var myArray = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ];
var myString = &quot;hello&quot;;
var myNumber = 3;
var myRegExp = /(\w+)\s(\w+)/;

typeof myFunction; // &quot;function&quot;
typeof myObject;   // &quot;object&quot;
typeof myArray;    // &quot;object&quot; -- Careful!
typeof myString;   // &quot;string&quot;
typeof myNumber;   // &quot;number&quot;
typeof null;       // &quot;object&quot; -- Careful!
typeof undefined;  // &quot;undefined&quot;
typeof meh;        // &quot;undefined&quot; -- undefined variable.
typeof myRegExp;   // &quot;function&quot; or &quot;object&quot; depending on environment.


if ( myArray.push && myArray.slice && myArray.join ) {
    // probably an array (this is called &quot;duck typing&quot;)
}

if ( Object.prototype.toString.call( myArray ) === &quot;[object Array]&quot; ) {
    // Definitely an array!
    // This is widely considered as the most robust way
    // to determine if a specific value is an Array.
}</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[类型]]></title>
        <link href="http://js101.co/javascript-101/types.html"/>
        <published>2015-03-09T00:00:00.000Z</published>
        <updated>2015-03-09T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/types.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <p>JavaScript 中的数据类型有两类：原始类型和对象。原始类型包括：</p>
<ul>
<li>字符串</li>
<li>数字</li>
<li>布尔</li>
<li>null</li>
<li>undefined</li>
</ul>
<h2 id="字符串">字符串</h2><p>字符串是被单引号或双引号包含的文本。最佳实践是始终保持使用一种引号。有时候字符串里的引号标记会和创建字符串的引号冲突，在这种情况下，可以使用 <code>\</code> 反斜线转义字符或者使用不同的引号。</p>
<pre>// Strings can be created with double or single quotes.
var a = &quot;I am a string&quot;;
var b = &#39;So am I!&#39;;
alert( a );
alert( b );</pre><pre>// Sometimes a string may contain quotation marks.
var statement1 = &#39;He said &quot;JavaScript is awesome!&quot;&#39;;
var statement2 = &quot;He said \&quot;JavaScript is awesome!\&quot;&quot;;</pre><h2 id="数字">数字</h2><p>数字是任何正或负的数值。整数和浮点数之间没有区别。</p>
<pre>// Numbers are any whole or floating point integer.
var num1 = 100;
var num2 = 100.10;
var num3 = 0.10;</pre><h2 id="布尔">布尔</h2><p>布尔类型是 <code>true</code> 或者 <code>false</code>。</p>
<pre>// Boolean values.
var okay = true;
var fail = false;</pre><h2 id="null-和-undefined">null 和 undefined</h2><p><code>null</code> 和 <code>undefined</code> 是 JavaScript 中的特殊类型。 Null 类型表示一个空值，类似于许多其他语言。 Undefined 类型表示变量还没有赋值的状态，可以通过两种方式来创建： 通过使用 <code>undefined</code> 关键字或者在定义变量的时候不赋值。</p>
<pre>// Define a null value.
var foo = null;

// Two ways to achieve an undefined value.
var bar1 = undefined;
var bar2;</pre><h2 id="对象">对象</h2><p>其他一切都是对象。JavaScript 有众多的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects" title="MDN - 内置对象">内置对象</a>，但本章只包括：</p>
<ul>
<li>对象</li>
<li>数组</li>
<li>函数</li>
</ul>
<p>最简单的创建对象的方法是被称为对象字面量的简写语法。这些简单的对象是无序的键值对集合。对象中的键通常被称为“属性”，属性的值可以是任何有效的 JavaScript 类型，甚至可以是另一个对象。创建或访问对象的属性，我们可以使用“点号表示法”或者“括号表示法”。</p>
<pre>// Using an empty object literal
var person1 = {};

// Assign properties using &quot;dot notation&quot;
person1.firstName = &quot;John&quot;;
person1.lastName = &quot;Doe&quot;;

// Access properties using &quot;dot notation&quot;
alert( person1.firstName + &quot; &quot; + person1.lastName );

// Creating an object with the object literal syntax:
var person2 = {
    firstName: &quot;Jane&quot;,
    lastName: &quot;Doe&quot;
};

alert( person2.firstName + &quot; &quot; + person2.lastName );

var people = {};

// Assign properties using &quot;bracket notation&quot;
// As mentioned, objects can also have objects as a property value
people[ &quot;person1&quot; ] = person1;
people[ &quot;person2&quot; ] = person2;

// Access properties using a mix of both bracket and dot notation
alert( people[ &quot;person1&quot; ].firstName );
alert( people[ &quot;person2&quot; ].firstName );</pre><p>如果被访问的属性还未定义，那么它的值将是 <code>undefined</code>。</p>
<pre>// Properties that have not been created are undefined.
var person = { name: &quot;John Doe&quot; };
alert( person.email ); // undefined</pre><p>在 <a href="/javascript-101/objects.html">对象</a> 部分会进一步讨论 JavaScript 对象。</p>
<h2 id="数组">数组</h2><p>数组是一类由它所包含的每一个项的索引排序的对象。索引开始于零，并延伸到已添加的项的数目，（项的数目）也是被称为 <code>.length</code> 的数组属性。类似一个基本对象，数组可以使用 <code>Array</code> 构造函数或者被称为数组字面量的简写语法来创建。</p>
<pre>// Creating an array with the constructor:
var foo = new Array;

// Creating an array with the array literal syntax:
var bar = [];</pre><p>在这两种语法之间有一个重要的区别。数组构造函数和数组字面量都可以在创建时加入要包含到数组的项，但是如果只是传入一个单一的数字项，数组构造函数会将该数字项当作数组的长度值。</p>
<pre>// The array literal returns a foo.length value of 1:
var foo = [ 100 ];
alert( foo[ 0 ] ); // 100
alert( foo.length ); // 1

// The array constructor returns a bar.length value of 100:
var bar = new Array( 100 );
alert( bar[ 0 ] ); // undefined
alert( bar.length ); // 100</pre><p>数组可以通过已经存在数组实例中的方法来进行相关操作。数组中的项可以通过括号和给定的索引来引用。如果索引不存在或者不包括任何值，则返回值 <code>undefined</code>。</p>
<p>一些常见的数组方法如下所示：</p>
<pre>// Using the push(), pop(), unshift() and shift() methods on an array.

var foo = [];

foo.push( &quot;a&quot; );
foo.push( &quot;b&quot; );

alert( foo[ 0 ] ); // a
alert( foo[ 1 ] ); // b

alert( foo.length ); // 2

foo.pop();

alert( foo[ 0 ] ); // a
alert( foo[ 1 ] ); // undefined

alert( foo.length ); // 1

foo.unshift( &quot;z&quot; );

alert( foo[ 0 ] ); // z
alert( foo[ 1 ] ); // a

alert( foo.length ); // 2

foo.shift();

alert( foo[ 0 ] ); // a
alert( foo[ 1 ] ); // undefined

alert( foo.length ); // 1</pre><p>还有更多的方法来操作数组，一部分将在<a href="/javascript-101/arrays.html">数组</a> 进一步讨论。更多的详细信息可在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" title="MDN - 数组参考">Mozilla 开发者网络</a> 找到。</p>
<h2 id="jquery-中的类型检测">jQuery 中的类型检测</h2><p>jQuery 提供了一些基本的实用方法，用于判断一个特定值的类型。类型检测会在 <a href="/javascript-101/testing-type.html">类型检测</a>部分进一步的讨论，这里有一些例子：</p>
<pre>// Checking the type of an arbitrary value.

var myValue = [ 1, 2, 3 ];

// Using JavaScript&#39;s typeof operator to test for primitive types:
typeof myValue === &quot;string&quot;; // false
typeof myValue === &quot;number&quot;; // false
typeof myValue === &quot;undefined&quot;; // false
typeof myValue === &quot;boolean&quot;; // false

// Using strict equality operator to check for null:
myValue === null; // false

// Using jQuery&#39;s methods to check for non-primitive types:
jQuery.isFunction( myValue ); // false
jQuery.isPlainObject( myValue ); // false
jQuery.isArray( myValue ); // true</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[保留字]]></title>
        <link href="http://js101.co/javascript-101/reserved-words.html"/>
        <published>2015-03-06T00:00:00.000Z</published>
        <updated>2015-03-06T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/reserved-words.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <p>JavaScript 有一些“保留字”，或有特殊意义的单词。除非你按照它们的本意来使用，否则你应该避免在代码中使用这些字词。</p>
<ul>
<li><code>break</code></li>
<li><code>case</code></li>
<li><code>catch</code></li>
<li><code>class</code></li>
<li><code>const</code></li>
<li><code>continue</code></li>
<li><code>debugger</code></li>
<li><code>default</code></li>
<li><code>delete</code></li>
<li><code>do</code></li>
<li><code>else</code></li>
<li><code>enum</code></li>
<li><code>export</code></li>
<li><code>extends</code></li>
<li><code>false</code></li>
<li><code>finally</code></li>
<li><code>for</code></li>
<li><code>function</code></li>
<li><code>if</code></li>
<li><code>implements</code></li>
<li><code>import</code></li>
<li><code>in</code></li>
<li><code>instanceof</code></li>
<li><code>interface</code></li>
<li><code>let</code></li>
<li><code>new</code></li>
<li><code>null</code></li>
<li><code>package</code></li>
<li><code>private</code></li>
<li><code>protected</code></li>
<li><code>public</code></li>
<li><code>return</code></li>
<li><code>static</code></li>
<li><code>super</code></li>
<li><code>switch</code></li>
<li><code>this</code></li>
<li><code>throw</code></li>
<li><code>true</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>var</code></li>
<li><code>void</code></li>
<li><code>while</code></li>
<li><code>with</code></li>
<li><code>yield</code></li>
</ul>
]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[语法基础]]></title>
        <link href="http://js101.co/javascript-101/syntax-basics.html"/>
        <published>2015-03-06T00:00:00.000Z</published>
        <updated>2015-03-06T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/syntax-basics.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <h3 id="注释">注释</h3><p>JavaScript 支持单行和多行注释。注释会被 JavaScript 引擎忽略，所以它对程序的结果没有影响。使用注释为其他开发者记录代码，像 <a href="http://usejsdoc.org/" title="JSDoc">JSDoc</a> 这类工具库，可以帮助生成基于注释的项目文档页面。</p>
<pre>// Single- and multi-line comments.

// This is an example of a single-line comment.

/*
 * this is an example
 * of a
 * multi-line
 * comment.
 */</pre><h3 id="空白">空白</h3><p>空白也被 JavaScript 引擎忽略。有许多工具可以用来去掉程序中的空白，降低了文件的整体大小和改进网络延迟。鉴于这类工具的可用性，空白应该加以利用，以使代码尽可能的易读。</p>
<pre>// Whitespace is insignificant.
var hello = &quot;Hello&quot;;
var world     =      &quot;World!&quot;;</pre><pre>// Semantic whitespace promotes readability.
// Readable code is good!
var foo = function() {

    for ( var i = 0; i &lt; 10; i++ ) {

        alert( i );

    }

};

foo();

// This is much harder to read!
var foo=function() {for(var i=0;i&lt;10;i++){alert(i);}};foo();</pre><h3 id="保留字">保留字</h3><p>当声明用户定义的变量和函数时，有少量的保留字不能被使用。一些保留字已经被实现，一些被保留以供将来使用，还有一些事因为历史原因而保留。<a href="/javascript-101/reserved-words.html">这里</a>是保留字的列表，对保留字的深入解释可以在<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Reserved_Words" title="MDN 保留字"> MDN 的 JavaScript 参考</a>当中找到。</p>
<h3 id="标识符">标识符</h3><p>标识符被用来给变量和函数的唯一名称，以便随后它们可以通过该名称被引用到。标识符名称必须遵循一些规则：</p>
<ul>
<li>不能是保留字。</li>
<li>只能由字母，数字，美元符号和下划线组成。</li>
<li>第一个字符不能是数字。</li>
</ul>
<p>命名标识符的最佳实践是选取一个将来也能对你或者其他开发者有意义的名称。</p>
<pre>// Valid identifier names.
var myAwesomeVariable = &quot;a&quot;;
var myAwesomeVariable2 = &quot;b&quot;;
var my_awesome_variable = &quot;c&quot;;
var $my_AwesomeVariable = &quot;d&quot;;
var _my_awesome_variable_$ = &quot;e&quot;;</pre><h3 id="变量定义">变量定义</h3><p>变量可以使用多个 <code>var</code> 语句来定义，或者使用单个组合的 <code>var</code> 语句。</p>
<pre>// This works:
var test = 1;
var test2 = function() { ... };
var test3 = test2( test );

// And so does this:
var test4 = 1,
    test5 = function() { ... },
    test6 = test2( test );</pre><p>变量可以在声明时不分配一个值，程序会给它们一个默认的值 <code>undefined</code>。</p>
<pre>var x;
x === undefined; // true</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[运行代码]]></title>
        <link href="http://js101.co/javascript-101/running-code.html"/>
        <published>2015-03-03T00:00:00.000Z</published>
        <updated>2015-03-03T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/running-code.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <h3 id="外部">外部</h3><p>第一种也是推荐的方式是在一个外部文件（带有 <code>.js</code> 扩展名）编写代码，然后可以使用 HTML <code>script</code> 元素并通过 <code>src</code> 属性指定文件的位置来引入到网页中。当你需要将代码重复使用在其他页面时，保持 JavaScript 在一个单独的文件中可以减少代码的重复。另外它也可以让浏览器将文件缓存到客户端的计算机上，减少网页加载时间。</p>
<pre>&lt;!-- Code is written in a .js file, included via the script tag src attribute. --&gt;
&lt;script src=&quot;/path/to/example.js&quot;&gt;&lt;/script&gt;</pre><h3 id="内嵌">内嵌</h3><p>第二种方式是直接将代码内嵌在网页中。它也是通过 HTML <code>script</code> 元素实现，但不是通过 <code>src</code> 属性指定一个文件，而是将代码放置在元素中间。虽然有些情况下可以使用这种方式，但大部分时间，最好是如上所述将我们的代码放置在外部文件中。</p>
<pre>&lt;!-- Embed code directly on a web page using script tags. --&gt;
&lt;script&gt;
alert( &quot;Hello World!&quot; );
&lt;/script&gt;</pre><h3 id="属性">属性</h3><p>最后一个选择是使用 HTML 元素的事件处理程序属性。这种方式是强烈不推荐的：</p>
<pre>&lt;!-- Inline code directly on HTML elements being clicked. --&gt;
&lt;a href=&quot;javascript:alert( &#39;Hello World&#39; );&quot;&gt;Click Me!&lt;/a&gt;
&lt;button onclick=&quot;alert( &#39;Good Bye World&#39; );&quot;&gt;Click Me Too!&lt;/button&gt;</pre><h3 id="位置">位置</h3><p>在上面的前两个方式中，代码的位置是重要的，并且需要根据情况而改变。如果你添加不访问页面元素的 JavaScript，你可以放心的把脚本放在 HTML <code>&lt;/head&gt;</code> 之前。但是，如果代码将于页面上的元素交互，就必须确保在执行代码时这些元素已经存在了。可以在下面的例子中看到这个常见的陷阱，一段查找 ID 为 <code>hello-world</code> 的元素脚本将会在页面定义元素之前执行。</p>
<pre>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;script&gt;
    // Attempting to access an element too early will have unexpected results.
    var title = document.getElementById( &quot;hello-world&quot; );
    console.log( title );
    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;hello-world&quot;&gt;Hello World&lt;/h1&gt;

&lt;/body&gt;
&lt;/html&gt;</pre><p>一个常见的模式是将脚本移动到页面的底部，HTML <code>&lt;/body&gt;</code> 前。这可以保证当执行代码时，元素已经在页面中定义了：</p>
<pre>&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;

&lt;h1 id=&quot;hello-world&quot;&gt;Hello World&lt;/h1&gt;
&lt;script&gt;
// Moving the script to the bottom of the page will make sure the element exists.
var title = document.getElementById( &quot;hello-world&quot; );
console.log( title );
&lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;</pre>]]>
        </content>
    </entry><entry>
        <title type="html"><![CDATA[入门]]></title>
        <link href="http://js101.co/javascript-101/getting-started.html"/>
        <published>2015-02-28T00:00:00.000Z</published>
        <updated>2015-02-28T00:00:00.000Z</updated>
        <id>http://js101.co/javascript-101/getting-started.html</id>
        <content type="html" xml:base="http://js101.co/" xml:lang="en">
            <![CDATA[ <h2 id="网页的解剖学">网页的解剖学</h2><p>在深入 JavaScript 之前，对网页的解剖有助于理解 JavaScript 是如何与其他网络技术密切合作的。</p>
<h2 id="html-是内容">HTML 是内容</h2><p>HTML 是用来定义和描述内容的标记语言。无论是博客文章，搜索引擎结果，或者电商网站，网页的核心内容都是用 HTML 编写的。语义标记是指 HTML 中用来描述内容的通用术语（头部，段落，图片等）。</p>
<h2 id="css-是表现">CSS 是表现</h2><p>CSS 是一个为 HTML 文档应用样式的附加语言。CSS 的全部都是关于如何通过定义字体，颜色等其他视觉美感，让内容更好看。CSS 的强大之处在于样式不再和内容夹杂，这意味着你可以将不同的样式应用到同一块内容，当构建良好跨设备响应式网站时，这是至关重要的。</p>
<h2 id="javascript-是交互">JavaScript 是交互</h2><p>在浏览器中，JavaScript 为 HTML 内容添加交互性和行为能力。没有 JavaScript，网页将会是静态和无聊的。JavaScript 使网页富有生命力。</p>
<p>看下面这个包含了 CSS 和 JavaScript 的简单 HTML 页面，了解这一切是如何组织在一起的：</p>
<pre>&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot; /&gt;
    &lt;title&gt;Hello World&lt;/title&gt;

    &lt;!-- CSS for presentation. --&gt;
    &lt;style&gt;
    h1 { font-size: 14px; color: hotpink; }
    button { color: red; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Hello World&lt;/h1&gt;
    &lt;button&gt;Click Me!&lt;/button&gt;

    &lt;!-- JavaScript for interactivity. --&gt;
    &lt;script&gt;

    // Get a handle on the first button element in the document.
    var button = document.querySelector( &quot;button&quot; );

    // If a user clicks on it, say hello!
    button.addEventListener( &quot;click&quot;, function( ev ) {
        alert( &quot;Hello&quot; );
    }, false);

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>在上面的例子中，HTML 是用来描述内容，“Hello World” 文本被 <code>h1</code> 元素描述为一个标题，“Click Me!”被 <code>button</code> 元素描述为一个按钮。<code>style</code> 代码块包含了改变标题颜色和字体大小的 CSS。<code>script</code> 代码块包含了给按钮添加交互的 JavaScript。当用户点击这个按钮，会弹出一个显示“Hello”的警告信息。</p>
<h2 id="web-的脚本语言">Web 的脚本语言</h2><p>JavaScript 最初设计为网页添加交互性，而不是成为一个通用语言，所以它被设计为脚本语言。<a href="http://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a> 被认为是比通用语言更高效，因为它们是为它们特定的领域（如 JavaScript 为网络浏览器）而优化。然而，最近的技术发展让 JavaScript 在服务器端大热（通过 <a href="http://nodejs.org/">Node.js</a>），所以它现在也可以用于代替 PHP,Ruby 或者 ASP等语言。本指南将专注于在浏览器中运行的 JavaScript。</p>
<p>“JavaScript” 这个名字有点误导性。尽管有相似的名字，但是 JavaScript 与 <a href="https://zh.wikipedia.org/wiki/Java">Java</a>（一种通用语言）没有任何关系。JavaScript 是基于开放式网络标准 ECMAScript。基于标准的语言不是任何一个实体或公司控制的－相反的，开发商们共同制定语言，这就是为什么 JavaScript 运行在每一个 Web 浏览器中，而无关操作系统或设备。</p>
<h2 id="你需要什么来开始学习-javascript-和-jquery">你需要什么来开始学习 JavaScript 和 jQuery</h2><ol>
<li>Web 浏览器</li>
<li>文本编辑器</li>
<li>开发者工具 (可选项)</li>
</ol>
<p>JavaScript 的最大优势之一是它的简单。它可以在任何操作系统上编写和运行，唯一的要求是一个网络浏览器和文本编辑器。也有许多工具可以让 JavaScript 开发更有效率，但它们是完全可选的。</p>
<h2 id="开发者工具">开发者工具</h2><p>许多浏览器附带的内置功能，通常被称为“开发者工具”，它提供了更好的视角来观察运行在浏览器里的 JavaScript 和 jQuery。虽然不是必须的，但当你调试代码错误时，你会发现开发者工具很有用。看看常见的浏览器开发者工具：</p>
<ul>
<li><a href="https://developer.apple.com/cn/technologies/safari/developer-tools.html">Safari 开发者工具</a></li>
<li><a href="https://developers.google.com/chrome-developer-tools/">Google Chrome Developer Tools</a></li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/ie/gg589507.aspx">IE 开发者工具</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Tools">火狐开发者工具</a></li>
<li><a href="http://www.opera.com/dragonfly/">Opera Dragonfly</a></li>
</ul>
]]>
        </content>
    </entry>
</feed>