<!DOCTYPE HTML>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.2">
    <meta name="theme" content="one 0.2">
    <title>JS101:&nbsp;Closures</title>
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="favicon" type="image/png" sizes="16x16" href="/favicon.ico" />
    <link rel="icon" sizes="16x16" type="image/png" href="/favicon-16x16.png" />
    <link rel="icon" sizes="32x32" type="image/png" href="/favicon-32x32.png" />
    <link rel="alternate" type="application/rss+xml" href="/feed.xml" title="JS101" />
    <link rel="stylesheet" href="../static/one.css" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-50612052-1']);
      _gaq.push(['_trackPageview']);
      _gaq.push(['_trackPageLoadTime']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = 'https://ssl.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class="header">
      <div class="container">
        <div class="brand">
          <a class="home" href="../">JS101</a>
        </div>
        <div class="menu" role="navigation">
          <a href="../../../../../feed.xml">订阅</a>
        </div>
      </div>
    </div>
    <div class="document yue">
<div class="hentry" itemscope itemtype="http://schema.org/Article">
  <h1 class="entry-title" itemprop="name">Closures</h1>
  <div class="entry-content" itemprop="articleBody"><p>Closures are an extension of the concept of scope. With closures, functions have access to variables that were available in the scope where the function was created. If that seems confusing, don’t worry: closures are generally best understood by example.</p>
<p>As shown in the <a href="/scope/">Scope</a> section, functions have access to changing variable values. The same sort of behavior exists with functions defined within loops – the function &quot;sees&quot; the change in the variable&#39;s value even after the function is defined, resulting in each function referencing the last value stored in the variable.</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Each function executed within the loop will reference</span>
<span class="comment">// the last value stored in i (5).</span>
<span class="comment">// This won't behave as we want it to - every 100 milliseconds, 5 will alert</span>
<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) {
    setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert( i );
    }, i * <span class="number">100</span> );
}</code></pre></div><p>Closures can be used to prevent this by creating a unique scope for each iteration – storing each unique value of the variable within its scope.</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Using a closure to create a new private scope</span>
<span class="comment">// fix: “close” the value of i inside createFunction, so it won't change</span>
<span class="keyword">var</span> createFunction = <span class="function"><span class="keyword">function</span><span class="params">( i )</span> {</span>
    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        alert( i );
    };
};

<span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ ) {
    setTimeout( createFunction( i ), i * <span class="number">100</span> );
}</code></pre></div><p>Closures can also be used to resolve issues with the <code>this</code> keyword, which is unique to each scope:</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Using a closure to access inner and outer object instances simultaneously.</span>
<span class="keyword">var</span> outerObj = {
    myName: <span class="string">"outer"</span>,
    outerFunction: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>

        <span class="comment">// Provide a reference to outerObj through innerFunction's closure</span>
        <span class="keyword">var</span> self = <span class="keyword">this</span>;
        <span class="keyword">var</span> innerObj = {
            myName: <span class="string">"inner"</span>,
            innerFunction: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                console.log( self.myName, <span class="keyword">this</span>.myName ); <span class="comment">// "outer inner"</span>
            }
        };

        innerObj.innerFunction();

        console.log( <span class="keyword">this</span>.myName ); <span class="comment">// "outer"</span>
    }
};

outerObj.outerFunction();</code></pre></div><h2 id="function-bind">Function.bind</h2><p>Closures can be particularly useful when dealing with callbacks. However, it is often better to use <code>Function.bind</code>, which will avoid any overhead associated with scope traversal.</p>
<p><code>Function.bind</code> is used to create a new function. When called, the new function then calls itself in the context of the supplied <code>this</code> value, using a given set of arguments that will precede any arguments provided when the new function was initially called.</p>
<p>As <code>.bind()</code> is a recent addition to ECMAScript 5, it may not be present in all browsers, which is something to be wary of when deciding whether to use it. However, it&#39;s possible to work around support by using <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">this shim</a> from MDN:</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Shim from MDN</span>
<span class="keyword">if</span> (!Function.prototype.bind) {

    Function.prototype.bind = <span class="function"><span class="keyword">function</span><span class="params">( oThis )</span> {</span>

        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) {
            <span class="comment">// closest thing possible to the ECMAScript 5 internal</span>
            <span class="comment">// IsCallable function</span>
            <span class="keyword">throw</span> <span class="keyword">new</span> TypeError( <span class="string">"Function.prototype.bind - what is trying to be bound is not callable"</span> );
        }

        <span class="keyword">var</span> fSlice = Array.prototype.slice,
            aArgs = fSlice.call( arguments, <span class="number">1</span> ),
            fToBind = <span class="keyword">this</span>,
            fNOP = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>},
            fBound = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
                <span class="keyword">return</span> fToBind.apply( <span class="keyword">this</span> <span class="keyword">instanceof</span> fNOP
                    ? <span class="keyword">this</span>
                    : oThis || window,
                    aArgs.concat( fSlice.call( arguments ) ) );
            };

        fNOP.prototype = <span class="keyword">this</span>.prototype;

        fBound.prototype = <span class="keyword">new</span> fNOP();

        <span class="keyword">return</span> fBound;
    };
}</code></pre></div><p>One of the simplest uses of <code>.bind()</code> is making a function that is called with a particular value for <code>this</code>, regardless of how it&#39;s called. A common mistake developers make is attempting to extract a method from an object, then later calling that method and expecting it to the use the origin object as its <code>this</code>. However, this can be solved by creating a bound function using the original object as demonstrated below:</p>
<div class="highlight"><pre><code class="javascript"><span class="comment">// Let's manipulate "this" with a basic example.</span>
<span class="keyword">var</span> user = <span class="string">"johnsmith"</span>;
<span class="keyword">var</span> module = {
    getUser: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> <span class="keyword">this</span>.user;
    },
    user: <span class="string">"janedoe"</span>
};

<span class="comment">// module.getUser() is called where "module" is "this"</span>
<span class="comment">// and "module.user" is returned.</span>

<span class="comment">// janedoe</span>
module.getUser();

<span class="comment">// let's now store a reference in the global version of "this"</span>
<span class="keyword">var</span> getUser = module.getUser;

<span class="comment">// getUser() called, "this" is global, "user" is returned</span>

<span class="comment">// johnsmith</span>
getUser();

<span class="comment">// store a ref with "module" bound as "this"</span>
<span class="keyword">var</span> boundGetUser = getUser.bind( module );

<span class="comment">// boundGetUser() called, "module" is "this" again, "module.user" returned.</span>

<span class="comment">// janedoe</span>
boundGetUser();</code></pre></div></div>
</div>
</div>
    <div class="footer">
      <p class="copyright">powered by <a href="http://lab.lepture.com/nico/">nico</a> 0.5.2</p>
    </div>
    <div class="github"><a class="github-link" href="https://github.com/7anshuai/js101">Fork me on GitHub</a></div>
    <script src="../static/one.js"></script>
  </body>
</html>