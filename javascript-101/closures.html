<!DOCTYPE HTML>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.2">
    <meta name="theme" content="one 0.2">
    <title>JS101:&nbsp;Closures</title>
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="favicon" type="image/png" sizes="16x16" href="/favicon.ico" />
    <link rel="icon" sizes="16x16" type="image/png" href="/favicon-16x16.png" />
    <link rel="icon" sizes="32x32" type="image/png" href="/favicon-32x32.png" />
    <link rel="alternate" type="application/rss+xml" href="/feed.xml" title="JS101" />
    <link rel="stylesheet" href="../static/one.css" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-50612052-1']);
      _gaq.push(['_trackPageview']);
      _gaq.push(['_trackPageLoadTime']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = 'https://ssl.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class="header">
      <div class="container">
        <div class="brand">
          <a class="home" href="../">JS101</a>
        </div>
        <div class="menu" role="navigation">
          <a href="../../../../../feed.xml">订阅</a>
        </div>
      </div>
    </div>
    <div class="document yue">
<div class="hentry" itemscope itemtype="http://schema.org/Article">
  <h1 class="entry-title" itemprop="name">Closures</h1>
  <div class="entry-content" itemprop="articleBody"><p>Closures are an extension of the concept of scope. With closures, functions have access to variables that were available in the scope where the function was created. If that seems confusing, don’t worry: closures are generally best understood by example.</p>
<p>As shown in the <a href="/scope/">Scope</a> section, functions have access to changing variable values. The same sort of behavior exists with functions defined within loops – the function &quot;sees&quot; the change in the variable&#39;s value even after the function is defined, resulting in each function referencing the last value stored in the variable.</p>
<pre>// Each function executed within the loop will reference
// the last value stored in i (5).
// This won&#39;t behave as we want it to - every 100 milliseconds, 5 will alert
for ( var i = 0; i &lt; 5; i++ ) {
    setTimeout(function() {
        alert( i );
    }, i * 100 );
}</pre><p>Closures can be used to prevent this by creating a unique scope for each iteration – storing each unique value of the variable within its scope.</p>
<pre>// Using a closure to create a new private scope
// fix: “close” the value of i inside createFunction, so it won&#39;t change
var createFunction = function( i ) {
    return function() {
        alert( i );
    };
};

for ( var i = 0; i &lt; 5; i++ ) {
    setTimeout( createFunction( i ), i * 100 );
}</pre><p>Closures can also be used to resolve issues with the <code>this</code> keyword, which is unique to each scope:</p>
<pre>// Using a closure to access inner and outer object instances simultaneously.
var outerObj = {
    myName: &quot;outer&quot;,
    outerFunction: function() {

        // Provide a reference to outerObj through innerFunction&#39;s closure
        var self = this;
        var innerObj = {
            myName: &quot;inner&quot;,
            innerFunction: function() {
                console.log( self.myName, this.myName ); // &quot;outer inner&quot;
            }
        };

        innerObj.innerFunction();

        console.log( this.myName ); // &quot;outer&quot;
    }
};

outerObj.outerFunction();</pre><h2 id="function-bind">Function.bind</h2><p>Closures can be particularly useful when dealing with callbacks. However, it is often better to use <code>Function.bind</code>, which will avoid any overhead associated with scope traversal.</p>
<p><code>Function.bind</code> is used to create a new function. When called, the new function then calls itself in the context of the supplied <code>this</code> value, using a given set of arguments that will precede any arguments provided when the new function was initially called.</p>
<p>As <code>.bind()</code> is a recent addition to ECMAScript 5, it may not be present in all browsers, which is something to be wary of when deciding whether to use it. However, it&#39;s possible to work around support by using <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind">this shim</a> from MDN:</p>
<pre>// Shim from MDN
if (!Function.prototype.bind) {

    Function.prototype.bind = function( oThis ) {

        if (typeof this !== &quot;function&quot;) {
            // closest thing possible to the ECMAScript 5 internal
            // IsCallable function
            throw new TypeError( &quot;Function.prototype.bind - what is trying to be bound is not callable&quot; );
        }

        var fSlice = Array.prototype.slice,
            aArgs = fSlice.call( arguments, 1 ),
            fToBind = this,
            fNOP = function() {},
            fBound = function() {
                return fToBind.apply( this instanceof fNOP
                    ? this
                    : oThis || window,
                    aArgs.concat( fSlice.call( arguments ) ) );
            };

        fNOP.prototype = this.prototype;

        fBound.prototype = new fNOP();

        return fBound;
    };
}</pre><p>One of the simplest uses of <code>.bind()</code> is making a function that is called with a particular value for <code>this</code>, regardless of how it&#39;s called. A common mistake developers make is attempting to extract a method from an object, then later calling that method and expecting it to the use the origin object as its <code>this</code>. However, this can be solved by creating a bound function using the original object as demonstrated below:</p>
<pre>// Let&#39;s manipulate &quot;this&quot; with a basic example.
var user = &quot;johnsmith&quot;;
var module = {
    getUser: function() {
        return this.user;
    },
    user: &quot;janedoe&quot;
};

// module.getUser() is called where &quot;module&quot; is &quot;this&quot;
// and &quot;module.user&quot; is returned.

// janedoe
module.getUser();

// let&#39;s now store a reference in the global version of &quot;this&quot;
var getUser = module.getUser;

// getUser() called, &quot;this&quot; is global, &quot;user&quot; is returned

// johnsmith
getUser();

// store a ref with &quot;module&quot; bound as &quot;this&quot;
var boundGetUser = getUser.bind( module );

// boundGetUser() called, &quot;module&quot; is &quot;this&quot; again, &quot;module.user&quot; returned.

// janedoe
boundGetUser();</pre></div>
</div>
</div>
    <div class="footer">
      <p class="copyright">powered by <a href="">nico</a> 0.5.2</p>
    </div>
    <div class="github"><a class="github-link" href="https://github.com/7anshuai/js101">Fork me on GitHub</a></div>
    <script src="../static/one.js"></script>
  </body>
</html>