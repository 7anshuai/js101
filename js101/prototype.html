<!DOCTYPE HTML>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta name="generator" content="nico 0.5.2">
    <meta name="theme" content="one 0.2">
    <meta name="baidu-site-verification" content="mQA8r0mibu">
    <title>JS101:&nbsp;原型</title>
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="favicon" type="image/png" sizes="16x16" href="/favicon.ico" />
    <link rel="icon" sizes="16x16" type="image/png" href="/favicon-16x16.png" />
    <link rel="icon" sizes="32x32" type="image/png" href="/favicon-32x32.png" />
    <link rel="alternate" type="application/rss+xml" href="/feed.xml" title="JS101" />
    <link rel="stylesheet" href="../static/one.css" />
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-50612052-1']);
      _gaq.push(['_trackPageview']);
      _gaq.push(['_trackPageLoadTime']);
      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = 'https://ssl.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>
  <body>
    <div class="header">
      <div class="container">
        <div class="brand">
          <a class="home" href="../">JS101</a>
        </div>
        <div class="menu" role="navigation">
          <a href="https://jsernews.com/../">新闻</a>
          <a href="../../../../../feed.xml">订阅</a>
        </div>
      </div>
    </div>
    <div class="document yue">
<div class="hentry" itemscope itemtype="http://schema.org/Article">
  <h1 class="entry-title" itemprop="name">原型</h1>
  <div class="entry-content" itemprop="articleBody"><p>当经过多年的学习面向对象编程之后，适应 JavaScript 可能会令人沮丧。特别是缺乏一个 <code>class</code> 关键词，引起混乱的一个原因。然而，JavaScript 的设计不一定是一个障碍 - 掌握其基于原型的继承会提高你对这门语言的理解。</p>
<p>首先需要明白的一件事情是面向<em>对象</em>与面向<em>类</em>编程之间的区别。JavaScript 给了我们需要做的大部分基于类的语言可以做到的事情的工具 － 我们只需要学习如何正确使用它。</p>
<p>让我们来简单的介绍一下原型属性，来看看它是如何可以加深我们的 JavaScript 的知识。</p>
<h2 id="原型属性">原型属性</h2><p>原型属性是一个内部属性，它被设计用来实现继承。这里所说的“继承”的意思是继承的一种具体形式。因为状态和方法都由对象保存，那么我们可以说结构，行为和状态都被继承（<a href="http://es5.github.com/#x4.2.1">ES5: Objects</a>）。而基于类的语言，状态是由实例保存，方法是由类保存。</p>
<p>构造函数是拥有名为 <code>prototype</code> 属性的函数：</p>
<div class="highlight"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span> {</span>
}

console.log(Animal.prototype);</code></pre></div><p>这将显示 <code>{}</code> -- <code>Animal</code> 对象拥有一个 <code>prototype</code> 属性，但它还没有任何用户定义的东西在里面。我们可以随意添加想要的值和方法：</p>
<div class="highlight"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span> {</span>
}

Animal.prototype.type = <span class="string">'Unknown'</span>;
Animal.prototype.weight = <span class="number">0</span>;
Animal.prototype.weightUnits = <span class="string">'kg'</span>;

Animal.prototype.toString = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="keyword">this</span>.type + <span class="string">', '</span> + <span class="keyword">this</span>.weight + <span class="keyword">this</span>.weightUnits;
};

<span class="keyword">var</span> molly = <span class="keyword">new</span> Animal();
molly.type = <span class="string">'Dog'</span>;
molly.weight = <span class="number">28</span>;

console.log(molly.toString());</code></pre></div><p>这将显示“Dog, 28kg”。我们可以将这些赋值语句通过对象字面量组合在一起：</p>
<div class="highlight"><pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span><span class="params">()</span> {</span>
}

Animal.prototype = {
  type: <span class="string">'Unknown'</span>,
  weight: <span class="number">0</span>,
  weightUnits: <span class="string">'kg'</span>,

  toString: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.type + <span class="string">', '</span> + <span class="keyword">this</span>.weight + <span class="keyword">this</span>.weightUnits;
  }
};</code></pre></div><p>相比于你可能熟悉的类，这看起来也不会太不一样。</p>
<h2 id="动态原型">动态原型</h2><p>属性可以动态的添加到对象中，简单的赋值即可：</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> molly = <span class="keyword">new</span> Animal()
  , harley = <span class="keyword">new</span> Animal();

molly.type = <span class="string">'Dog'</span>;
molly.weight = <span class="number">28</span>;

harley.type = <span class="string">'Dog'</span>;
harley.weight = <span class="number">38</span>;
harley.name = <span class="string">'Harley'</span>;

console.log(molly);
console.log(harley);

<span class="comment">// { type: 'Dog', weight: 28 }</span>
<span class="comment">// { type: 'Dog', weight: 38, name: 'Harley' }</span></code></pre></div><p>在这里添加 <code>name</code> 属性只会影响该实例。然而，构造函数的原型可以改变，它会影响到所有通过原型制造的对象：</p>
<div class="highlight"><pre><code class="javascript">Animal.prototype.weightUnits = <span class="string">'oz'</span>;

console.log(molly.toString())
<span class="comment">// Now displays 'Dog, 28oz'</span></code></pre></div><p>这就是为什么人们会夸耀自己的库没有修改原生原型，或仅做安全的改动 －－ 因为完全有可能改变像 <code>String</code> 这样的对象预期的内置功能而产生问题：</p>
<div class="highlight"><pre><code class="javascript">String.prototype.match = <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="literal">true</span>;
};

console.log(<span class="string">'alex'</span>.match(<span class="regexp">/1234/</span>));</code></pre></div><p>这将返回 <code>true</code>，所以现在我已经成功的破坏了一个很多 JavaScript 程序依赖的基础方法。</p>
<p>修改原生的原型并不总是坏事；可以利用它做有用的事情，例如给旧的浏览器打补丁以支持更现代版本的 ECMAScript。</p>
<p>如果我们更换 <code>prototype</code> 属性会发生什么？</p>
<div class="highlight"><pre><code class="javascript"><span class="keyword">var</span> molly = <span class="keyword">new</span> Animal()
  , harley;

molly.type = <span class="string">'Dog'</span>;
molly.weight = <span class="number">28</span>;

Animal.prototype = {
  toString: <span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
    <span class="keyword">return</span> <span class="string">'...'</span>;
  }
};

harley = <span class="keyword">new</span> Animal;
harley.type = <span class="string">'Dog'</span>;
harley.weight = <span class="number">38</span>;

console.log(molly.toString());
console.log(harley.toString());

<span class="comment">// Dog, 28kg</span>
<span class="comment">// ...</span></code></pre></div><p>尽管改变原型会影响所有实例，但替换一个构造函数的原型完全不影响旧的实例。为什么？好吧，实例拥有一个原型的<em>引用</em>，而不是一个个分散的拷贝。想象它是这样的，每一个由 <code>new</code> 关键词创建的实例都<em>连接</em>到构造函数的原型。</p>
</div>

  <div class="entry-meta">
    <time class="updated" datetime="2016-10-01T00:00:00.000Z" itemprop="dateModified">Saturday, Oct 1st, 2016</time>
  </div><div class="ds-thread" data-thread-key="df24f8aeea459c227966f86dd8a84d4e" data-title="JS101: 原型"></div>
<script type="text/javascript">
  var duoshuoQuery = {short_name:"js101"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>
</div>
</div>
    <div class="footer">
 <p class="copyright">Maintained by <a href="http://7anshuai.js.org/">@7anshuai</a></p>
      <p class="copyright">powered by <a href="http://lab.lepture.com/nico/">nico</a> 0.5.2</p>
    </div>
    <div class="github"><a class="github-link" href="https://github.com/7anshuai/js101">Fork me on GitHub</a></div>
    <script src="../static/one.js"></script>
  </body>
</html>